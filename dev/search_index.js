var documenterSearchIndex = {"docs":
[{"location":"2D/flux/#Two-dimensional-square-lattice-model-with-flux","page":"Square Lattice w/ Flux","title":"Two-dimensional square lattice model with flux","text":"","category":"section"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"A two-dimensional example is presented here:","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"julia> function H₀(k, p)\n           k1, k2 = k\n           Hsize, ν = p\n           t = 1\n\n           Hmat = zeros(ComplexF64, Hsize, Hsize)\n\n           ϕ = 2π * ν / Hsize\n\n           for i in 1:Hsize\n               Hmat[i, i] = -2t * cos(k2 - i * ϕ)\n           end\n\n           for i in 1:Hsize-1\n               Hmat[i, i+1] = -t\n               Hmat[i+1, i] = -t\n           end\n\n           Hmat[1, Hsize] = -t * exp(-im * k1)\n           Hmat[Hsize, 1] = -t * exp(im * k1)\n\n           Hmat\n       end","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"To calculate the dispersion, run:","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"julia> H(k) = H₀(k, (6, 1))\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"(Image: Dispersion of 2D square lattice with flux model)","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"Then we can compute the Chern numbers using FCProblem:","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"julia> prob = FCProblem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"The output is:","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"FCSolution{Vector{Int64}, Int64}([1, 1, -2, -2, 1, 1], 0)","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the first Chern number for each band.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the first Chern numbers for each band. Total is a quantity that should always return zero.","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"You can access these values as follows:","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"julia> sol.TopologicalNumber\n6-element Vector{Int64}:\n  1\n  1\n -2\n -2\n  1\n  1\n\njulia> sol.Total\n0","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"julia> H(k, p) = H₀(k, (6, p));\njulia> param = 0:6;\n\njulia> prob = FCProblem(H);\njulia> sol = calcPhaseDiagram(prob, param; plot=true)\n(param = 0:6, nums = [0 0 … 0 0; 1 1 … 1 1; … ; -1 -1 … -1 -1; 0 0 … 0 0])","category":"page"},{"location":"2D/flux/","page":"Square Lattice w/ Flux","title":"Square Lattice w/ Flux","text":"(Image: One-dimensional phase diagram)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"T. Fukui, Y. Hatsugai and H. Suzuki. Chern Numbers in Discretized Brillouin Zone: Efficient Method of Computing (Spin) Hall Conductances. J. Phys. Soc. Jpn. 74, 1674 (2005).\n\n\n\nM. Mochol-Grzelak, A. Dauphin, A. Celi and M. Lewenstein. Efficient Algorithm to Compute the Second Chern Number in Four Dimensional Systems. Quantum Sci. Technol. 4, 014009 (2018).\n\n\n\nT. Fukui and Y. Hatsugai. Quantum Spin Hall Effect in Three Dimensional Materials: Lattice Computation of Z2 Topological Invariants and Its Application to Bi and Sb. J. Phys. Soc. Jpn. 76, 053702 (2007).\n\n\n\nK. Shiozaki. A Discrete Formulation of the Kane-Mele mathbb Z_2 Invariant (May 2023), arXiv:2305.05615 [cond-mat].\n\n\n\nM. Hirayama, R. Okugawa and S. Murakami. Topological semimetals studied by ab initio calculations. Journal of the Physical Society of Japan 87, 041002 (2017).\n\n\n\nK.-Y. Yang, Y.-M. Lu and Y. Ran. Quantum Hall effects in a Weyl semimetal: Possible application in pyrochlore iridates. Physical Review B 84, 075129 (2011).\n\n\n\nM. Hirayama, R. Okugawa, S. Ishibashi, S. Murakami and T. Miyake. Weyl Node and Spin Texture in Trigonal Tellurium and Selenium. Physical Review Letters 114, 206401 (2015).\n\n\n\nY. Du, X. Bo, D. Wang, E.-j. Kan, C.-G. Duan, S. Y. Savrasov and X. Wan. Emergence of topological nodal lines and type-II Weyl nodes in the strong spin-orbit coupling system   InNb  X 2    (  X = S  ,Se). Physical Review B 96, 235152 (2017).\n\n\n\n","category":"page"},{"location":"1D/SSH/#The-Su-Schriffer-Heeger-(SSH)-model","page":"SSH model","title":"The Su-Schriffer-Heeger (SSH) model","text":"","category":"section"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"Here's a simple example of the SSH Hamiltonian:","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"julia> using TopologicalNumbers\njulia> function H₀(k, p)\n           t₁ = 1\n           t₂ = p\n\n           [\n               0 t₁+t₂*exp(-im * k)\n               t₁+t₂*exp(im * k) 0\n           ]\n       end","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"The band structure is computed as follows:","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"julia> H(k) = H₀(k, 1.1)\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"(Image: Band structure of SSH model)","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"Next, we can calculate the winding numbers using BPProblem:","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"julia> prob = BPProblem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"The output is:","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"BPSolution{Vector{Int64}, Int64}([1, 1], 0)","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"The first argument TopologicalNumber in the named tuple is a vector that stores the winding number for each band.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the winding numbers for each band (mod 2). Total is a quantity that should always return zero.","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"You can access these values as follows:","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"julia> sol.TopologicalNumber\n2-element Vector{Int64}:\n 1\n 1\n\njulia> sol.Total\n0","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"A one-dimensional phase diagram is given by:","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"julia> param = range(-2.0, 2.0, length=1001)\n\njulia> prob = BPProblem(H₀);\njulia> sol = calcPhaseDiagram(prob, param; plot=true)\n(param = -2.0:0.004:2.0, nums = [1 1; 1 1; … ; 1 1; 1 1])","category":"page"},{"location":"1D/SSH/","page":"SSH model","title":"SSH model","text":"(Image: One-dimensional phase diagram of SSH model)","category":"page"},{"location":"lib/public/#Public","page":"Public","title":"Public","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [TopologicalNumbers]\nPrivate = false","category":"page"},{"location":"lib/public/#TopologicalNumbers.BP","page":"Public","title":"TopologicalNumbers.BP","text":"Fukui-Hatsugai-Suzuki method [1]\n\nDefinition\n\nThe Berry phase of the nth band nu_n is defined by\n\nnu_n=frac1pisum_kinmathrmBZU_n(k)\n\nThe range mathrmBZ(Brillouin Zone) is kin02pi. U_ni(k) is the link variable at wavenumber k. e_1 is the unit vector.\n\nU_n(k)=braketPsi_n(k)Psi_n(k+e_1)\n\nketPsi_n(k)\n\nis the wave function of the nth band.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.BPProblem","page":"Public","title":"TopologicalNumbers.BPProblem","text":"struct BPProblem{T1<:Function,T2<:Union{Tuple,AbstractVector,Int},T3<:Real,T4<:Bool} <: TopologicalNumbersProblems\n\nThe BPProblem struct represents a problem for calculating Berry phase.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 1.\nN::T2: The number of points for one direction in the Brillouin zone. Default is 51.\ngapless::T3: The threshold for considering a band as gapless. Default is 0.0.\nrounds::T4: A boolean indicating whether to round a returned variable. Default is true.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.BPProblem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.BPProblem","text":"BPProblem(H, N)\n\nConstructs a Berry phase problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 1.\nN: The number of points for one direction in the Brillouin zone.\n\nReturns\n\nA BPProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.BPProblem-Tuple{Any}","page":"Public","title":"TopologicalNumbers.BPProblem","text":"BPProblem(H)\n\nConstructs a Berry phase problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 1.\n\nReturns\n\nA BPProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.BPSolution","page":"Public","title":"TopologicalNumbers.BPSolution","text":"BPSolution{T1,T2} <: TopologicalNumbersSolutions\n\nThe BPSolution struct represents a solution for calculating Berry phase.\n\nFields\n\nTopologicalNumber::T1: The Berry phase for each energy bands.\nTotal::T2: The total Berry phase.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.Evar","page":"Public","title":"TopologicalNumbers.Evar","text":"\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.FCProblem","page":"Public","title":"TopologicalNumbers.FCProblem","text":"FCProblem{T1<:Function,T2<:Union{Tuple,AbstractVector,Int},T3<:Real,T4<:Bool} <: TopologicalNumbersProblems\n\nA struct representing a problem for calculating the first Chern number.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 2.\nN::T2: The number of points for one direction in the Brillouin zone. Default is 51.\ngapless::T3: The threshold for considering a band as gapless. Default is 0.0.\nrounds::T4: A boolean indicating whether to round a returned variable. Default is true.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.FCProblem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.FCProblem","text":"FCProblem(H, N)\n\nConstructs a first Chern number problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 2.\nN: The number of points for one direction in the Brillouin zone.\n\nReturns\n\nA FCProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.FCProblem-Tuple{Any}","page":"Public","title":"TopologicalNumbers.FCProblem","text":"FCProblem(H)\n\nConstructs a first Chern number problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 2.\n\nReturns\n\nA FCProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.FCSolution","page":"Public","title":"TopologicalNumbers.FCSolution","text":"FCSolution{T1,T2} <: TopologicalNumbersSolutions\n\nThe FCSolution struct represents a solution for calculating the first Chern number.\n\nFields\n\nTopologicalNumber::T1: The first Chern number for each energy bands.\nTotal::T2: The total of the first Chern number.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.FHS","page":"Public","title":"TopologicalNumbers.FHS","text":"Fukui-Hatsugai-Suzuki method [1]\n\nDefinition\n\nThe first Chern number of the nth band nu_n is defined by\n\nnu_n=frac12pisum_bmkinmathrmBZmathrmImleftmathrmLogleftU_n1(bmk)U_n2(bmk+bme_1)U_n1^*(bmk+bme_2)U_n2^*(bmk)rightright\n\nThe range mathrmBZ(Brillouin Zone) is bmkin02pi^2. U_ni(bmk) is the link variable at wavenumber bmk. bme_i is the unit vector.\n\nU_ni(bmk)=braketPsi_n(bmk)Psi_n(bmk+bme_i)\n\nketPsi_n(bmk) is the wave function of the nth band.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.FHS2","page":"Public","title":"TopologicalNumbers.FHS2","text":"Fukui-Hatsugai-Suzuki method [2]\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.FHSlocal2","page":"Public","title":"TopologicalNumbers.FHSlocal2","text":"Fukui-Hatsugai-Suzuki method [1]\n\nDefinition\n\nThe Berry flux at the wavenumber bmk of the nth band F_n(bmk) is defined by\n\nF_n(bmk)=f_n(bmk)-df_n(bmk)\n\nf_n(bmk)=frac12pimathrmImleftmathrmLogleftU_n1(bmk)U_n2(bmk+bme_1)U_n1^*(bmk+bme_2)U_n1^*(bmk)rightright\n\ndf_n(bmk)=frac12pimathrmImleftmathrmLogU_n1(bmk)+mathrmLogU_n2(bmk+bme_1)-mathrmLogU_n1(bmk+bme_2)-mathrmLogU_n1(bmk)right\n\nU_ni(bmk) is the link variable at wavenumber bmk. bme_i is the unit vector.\n\nU_ni(bmk)=braketPsi_n(bmk)Psi_n(bmk+bme_i)\n\nketPsi_n(bmk) is the wave function of the nth band.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.FHSlocal3","page":"Public","title":"TopologicalNumbers.FHSlocal3","text":"\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.FHSsurface","page":"Public","title":"TopologicalNumbers.FHSsurface","text":"\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.LBFProblem","page":"Public","title":"TopologicalNumbers.LBFProblem","text":"LBFProblem{T1<:Function,T2<:AbstractVector,T3<:Union{Tuple,AbstractVector,Int},T4<:Real,T5<:Bool} <: TopologicalNumbersProblems\n\nA struct representing a problem for calculating the k-local value of Berry flux.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k) that defines the system. k is an AbstractVector (or a Tuple) of the wavenumber vector. Dimension of k must be 2.\nn::T2: An AbstractVector (or a Tuple) including two elements of Int, which represents wavenumber (2pi nN) when calculating Berry flux. Dimension of n must be 2.\nN::T3: The number of points for one direction in the Brillouin zone. Default is 51.\ngapless::T4: The threshold for considering a band as gapless. Default is 0.0.\nrounds::T5: A boolean indicating whether to round a returned variable. Default is true.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.LBFProblem-Tuple{Any, Any, Any}","page":"Public","title":"TopologicalNumbers.LBFProblem","text":"LBFProblem(H, n, N)\n\nConstructs a local Berry flux problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 2.\nn: An AbstractVector (or a Tuple) including two elements of Int, which represents wavenumber (2pi nN) when calculating Berry flux. Dimension of n must be 2.\nN: The number of points for one direction in the Brillouin zone.\n\nReturns\n\nA LBFProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.LBFProblem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.LBFProblem","text":"LBFProblem(H, n)\n\nConstructs a local Berry flux problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 2.\nn: An AbstractVector (or a Tuple) including two elements of Int, which represents wavenumber (2pi nN) when calculating Berry flux. Dimension of n must be 2.\n\nReturns\n\nA LBFProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.LBFSolution","page":"Public","title":"TopologicalNumbers.LBFSolution","text":"LBFSolution{T1,T2} <: TopologicalNumbersSolutions\n\nThe LBFSolution struct represents a solution for calculating the k-local value of Berry flux.\n\nFields\n\nTopologicalNumber::T1: The local Berry flux for each energy bands.\nn::T2: An AbstractVector (or a Tuple) including two elements of Int, which represents wavenumber (2pi nN) when calculating Berry flux.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.SCProblem","page":"Public","title":"TopologicalNumbers.SCProblem","text":"SCProblem{T1<:Function,T2<:Union{Tuple,AbstractVector,Int},T3<:Union{Real,Nothing},T4<:Bool} <: TopologicalNumbersProblems\n\nA struct representing a problem for calculating the second Chern number.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 4.\nN::T2: The number of points in the Brillouin zone. Type of Int means the uniform mesh. You can also specify the mesh by giving a tuple or a vector. Default is 30.\nNfill::T3: The number of filled bands. nothing means the half-filling. Default is nothing.\nRV::T4: A boolean indicating whether to return a real value. Default is true.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.SCProblem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.SCProblem","text":"SCProblem(H, N)\n\nConstructs a second Chern number problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 4.\nN: The number of points in the Brillouin zone. Type of Int means the uniform mesh. You can also specify the mesh by giving a tuple or a vector.\n\nReturns\n\nA SCProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.SCProblem-Tuple{Any}","page":"Public","title":"TopologicalNumbers.SCProblem","text":"SCProblem(H)\n\nConstructs a second Chern number problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 4.\n\nReturns\n\nA SCProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.SCSolution","page":"Public","title":"TopologicalNumbers.SCSolution","text":"SCSolution{T} <: TopologicalNumbersSolutions\n\nThe SCSolution struct represents a solution for calculating the second Chern number.\n\nFields\n\nTopologicalNumber::T: The second Chern number.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.Shio","page":"Public","title":"TopologicalNumbers.Shio","text":"Shiozaki method [4]\n\nDefinition\n\nThe mathbbZ_2 number of the 2nth (and 2n-1th) band nu_n is defined by\n\nnu_n=F_n-left(P_n(0)-P_n(pi)right)\n\nF_n is the Berry flux of the nth band in the mathrmBZ. The range mathrmBZ is bmkin02pitimes0pi half of BZ(Brillouin Zone).\n\nF_n=frac12pisum_bmkinmathrmBZmathrmImleftmathrmLogleftU_n1(bmk)U_n2(bmk+bme_1)U_n1^*(bmk+bme_2)U_n1^*(bmk)rightright\n\nP_n(k_2) is the time-reversal polarization at wavenumber k_2.\n\nP_n(k_2)=frac12pifracmathrmPfomega(0k_2)mathrmPfomega(pik_2)sum_k_1=0^pi-e_1U_n1(bmk)\n\nU_ni(bmk) is the link variable at wavenumber bmk. bme_i is the unit vector.\n\nU_ni(bmk)=braketPsi_n(bmk)Psi_n(bmk+bme_i)\n\nketPsi_n(bmk) is the wave function of the 2nth (and 2n-1th) band. omega(bmk) is the unitary matrix given by\n\nomega(bmk)=braPsi(-bmk)TketPsi(bmk)\n\nT is the time-reversal operator.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.UseMPI","page":"Public","title":"TopologicalNumbers.UseMPI","text":"UseMPI{T}(MPI::T) <: TopologicalNumbersMultiProcess\n\nA struct representing the use of MPI for parallel computing in the TopologicalNumbers package.\n\nArguments\n\nMPI: An object representing the MPI library.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.UseSingleThread","page":"Public","title":"TopologicalNumbers.UseSingleThread","text":"UseSingleThread <: TopologicalNumbersSingleProcess\n\nA struct representing the use of a single thread for parallel processing in the TopologicalNumbers module.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.WCSProblem","page":"Public","title":"TopologicalNumbers.WCSProblem","text":"WCSProblem{T1<:Function,T2<:String,T3<:Int,T4<:Union{Tuple,AbstractVector,Int},T5<:Real,T6<:Bool} <: TopologicalNumbersProblems\n\nA struct representing a problem for finding and calculating the Weyl points.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nkn::T2: Compute the Chern number of the plane perpendicular to the \"kn\" direction in Brillouin zone (\"k1\", \"k2\", \"k3\").\nkn_mesh::T3: Number of mesh in \"kn\" direction. Default is 51.\nN::T4: The number of points for one direction in the Brillouin zone. Default is 51.\ngapless::T5: The threshold for considering a band as gapless. Default is 0.0.\nrounds::T6: A boolean indicating whether to round a returned variable. Default is true.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.WCSProblem-NTuple{4, Any}","page":"Public","title":"TopologicalNumbers.WCSProblem","text":"WCSProblem(H, kn, N1, N2)\n\nConstructs a problem for finding and calculating the Weyl points with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nkn: Compute the Chern number of the plane perpendicular to the \"kn\" direction in Brillouin zone (\"k1\", \"k2\", \"k3\").\nN1: Number of mesh in \"kn\" direction.\nN2: The number of points for one direction in the Brillouin zone.\n\nReturns\n\nA WCSProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.WCSProblem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.WCSProblem","text":"WCSProblem(H, kn)\n\nConstructs a problem for finding and calculating the Weyl points with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nkn: Compute the Chern number of the plane perpendicular to the \"kn\" direction in Brillouin zone (\"k1\", \"k2\", \"k3\").\n\nReturns\n\nA WCSProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.WCSProblem-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Int64","page":"Public","title":"TopologicalNumbers.WCSProblem","text":"WCSProblem(H, kn, N::T) where {T<:Int}\n\nConstructs a problem for finding and calculating the Weyl points with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nkn: Compute the Chern number of the plane perpendicular to the \"kn\" direction in Brillouin zone (\"k1\", \"k2\", \"k3\").\nN: The number of points for one direction in the Brillouin zone.\n\nReturns\n\nA WCSProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.WCSSolution","page":"Public","title":"TopologicalNumbers.WCSSolution","text":"WCSSolution{T1,T2,T3} <: TopologicalNumbersSolutions\n\nThe WCSSolution struct represents a solution for finding and calculating the Weyl points.\n\nFields\n\nkn::T1: Compute the Chern number of the plane perpendicular to the \"kn\" direction in Brillouin zone (\"k1\", \"k2\", \"k3\").\nparam::T2: Wavenumber parameters in \"kn\" direction.\nnums::T3: The Chern number for each energy bands and each wavenumber parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.WNProblem","page":"Public","title":"TopologicalNumbers.WNProblem","text":"WNProblem{T1<:Function,T2<:AbstractVector,T3<:Int,T4<:Real,T5<:Bool} <: TopologicalNumbersProblems\n\nA struct representing a problem for calculating the Weyl nodes.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nn::T2: An AbstractVector (or a Tuple) including two elements of Int, which represents wavenumber (2pi nN). Dimension of n must be 3.\nN::T3: The number of points for one direction in the Brillouin zone. Default is 51.\ngapless::T4: The threshold for considering a band as gapless. Default is 0.0.\nrounds::T5: A boolean indicating whether to round a returned variable. Default is true.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.WNProblem-Tuple{Any, Any, Any}","page":"Public","title":"TopologicalNumbers.WNProblem","text":"WNProblem(H, n, N)\n\nConstructs a problem for calculating the Weyl nodes with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nn: An AbstractVector (or a Tuple) including two elements of Int, which represents wavenumber (2pi nN). Dimension of n must be 3.\nN: The number of points for one direction in the Brillouin zone.\n\nReturns\n\nA WNProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.WNProblem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.WNProblem","text":"WNProblem(H, n)\n\nConstructs a problem for calculating the Weyl nodes with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nn: An AbstractVector (or a Tuple) including two elements of Int, which represents wavenumber (2pi nN). Dimension of n must be 3.\n\nReturns\n\nA WNProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.WNSolution","page":"Public","title":"TopologicalNumbers.WNSolution","text":"WNSolution{T1,T2,T3} <: TopologicalNumbersSolutions\n\nThe WNSolution struct represents a solution for calculating the Weyl nodes.\n\nFields\n\nTopologicalNumber::T1: \nn::T2: \nN::T3: \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.WPProblem","page":"Public","title":"TopologicalNumbers.WPProblem","text":"WPProblem{T1<:Function,T2<:Int,T3<:AbstractVector,T4<:Bool} <: TopologicalNumbersProblems\n\nA struct representing a problem for calculating the Weyl points.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nN::T2: The number of meshes when discretizing the Brillouin Zone. The nth iteration divides the Brillouin zone into 1N^n. Default is 10.\ngapless::T3 The threshold that determines the state to be degenerate. The nth iteration adopts the threshold value of the nth value of the vector. The number of iterations can be varied by the length of the vector. Default is [1e-1, 1e-2, 1e-3, 1e-4].\nrounds::T4: A boolean indicating whether to round a returned variable. Default is true.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.WPProblem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.WPProblem","text":"WPProblem(H, N)\n\nConstructs a problem for calculating the Weyl points with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\nN: The number of meshes when discretizing the Brillouin Zone. The nth iteration divides the Brillouin zone into 1N^n.\n\nReturns\n\nA WPProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.WPProblem-Tuple{Any}","page":"Public","title":"TopologicalNumbers.WPProblem","text":"WPProblem(H)\n\nConstructs a problem for calculating the Weyl points with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector. Dimension of k must be 3.\n\nReturns\n\nA WPProblem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.WPSolution","page":"Public","title":"TopologicalNumbers.WPSolution","text":"WPSolution{T1,T2,T3} <: TopologicalNumbersSolutions\n\nThe WPSolution struct represents a solution for calculating the Weyl points.\n\nFields\n\nWeylPoint::T1: \nN::T2: \nNodes::T3:\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.Z2Problem","page":"Public","title":"TopologicalNumbers.Z2Problem","text":"Z2Problem{T1<:Function,T2<:Union{Tuple,AbstractVector,Int},T3<:Bool} <: TopologicalNumbersProblems\n\nA struct representing a problem for calculating the Z2 number.\n\nFields\n\nH::T1: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 2.\nN::T2: The number of points for one direction in the Brillouin zone. Default is 50.\nrounds::T3: A boolean indicating whether to round a returned variable. Default is true.\nTR::T3: A boolean indicating whether to calculate the remaining part of the Brillouin zone. If true, solve returns an additional result TRTopologicalNumber. If the calculation is done nomally, TRTopologicalNumber is equal to TopologicalNumber. Default is false.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.Z2Problem-Tuple{Any, Any}","page":"Public","title":"TopologicalNumbers.Z2Problem","text":"Z2Problem(H, N)\n\nConstructs a Z2 number problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 2.\nN: The number of points for one direction in the Brillouin zone.\n\nReturns\n\nA Z2Problem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.Z2Problem-Tuple{Any}","page":"Public","title":"TopologicalNumbers.Z2Problem","text":"Z2Problem(H)\n\nConstructs a Z2 number problem with the default parameters.\n\nArguments\n\nH: The Hamiltonian function H=H(k, p) that defines the system. k is a abstract vector (or a tuple) of the wavenumber vector and p contains parameter. Dimension of k must be 2.\n\nReturns\n\nA Z2Problem object.\n\nExample\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.Z2Solution","page":"Public","title":"TopologicalNumbers.Z2Solution","text":"Z2Solution{T1,T2,T3} <: TopologicalNumbersSolutions\n\nThe Z2Solution struct represents a solution for calculating Z2 number.\n\nFields\n\nTopologicalNumber::T1: The Z2 number for each pair of energy bands.\nTRTopologicalNumber::T2: The Z2 number for the remaining part of the Brillouin zone. This field is only returned when TR is true in Z2Problem.\nTotal::T3: The total Z2 number.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#TopologicalNumbers.BHZ-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{Tuple, AbstractVector}, T2<:Union{Tuple, AbstractVector}}","page":"Public","title":"TopologicalNumbers.BHZ","text":"Hamiltonian of the Bernevig–Hughes–Zhang (BHZ) model.\n\n BHZ(k::T1, p::T2) where {T1<:Union{AbstractVector,Tuple}, T2<:Union{AbstractVector,Tuple}}\n\nArguments\n\nk::T1: two-dimensional wavenumber k.\np::T2: parameters defined as below.\n\nDefinition\n\nHamiltonian of the BHZ model is defined as\n\nH(k)=beginpmatrix\n    h_0(bmk)+h_3(bmk)   0                             h_5(bmk)-ih_4(bmk)  0                            \n    0                             h_0(bmk)-h_3(bmk)   0                             h_5(bmk)-ih_4(bmk) \n    h_5(bmk)+ih_4(bmk)  0                             h_0(bmk)-h_3(bmk)   0                            \n    0                             h_5(bmk)+ih_4(bmk)  0                             h_0(bmk)+h_3(bmk)\nendpmatrix\n\nbeginalign*\n     h_0(bmk)=-(t_ss-t_pp)(cos(k_1)+cos(k_2))+frac(epsilon_s+epsilon_p)2 \n     h_3(bmk)=2t_spsin(k_2) \n     h_4(bmk)=2t_spsin(k_1) \n     h_5(bmk)=-(t_ss+t_pp)(cos(k_1)+cos(k_2))+frac(epsilon_s-epsilon_p)2\nendalign*\n\nwhere t_sp is the amplitude of the mixed hopping between s- and p-orbitals in the tight binding model. t_ss is the hopping between s-orbitals, t_pp is the hopping between p-orbitals, and t_1=t_s-t_p, t_2=t_s+t_p. epsilon_s and epsilon_p are the site potential terms for the s- and p-orbitals, epsilon_1epsilon_ss+epsilon_p, epsilon_2=epsilon_s-epsilon_p Nondimensionalize with t_sp=t_1=epsilon_1=1 and epsilon_2t_2=p.\n\nExamples\n\n```julia julia> BHZ([0, π/3], [0.5, 0.5]) 4×4 Matrix{ComplexF64}:  0.732051+0.0im       0.0+0.0im      -0.5+0.0im       0.0+0.0im       0.0+0.0im  -2.73205+0.0im       0.0+0.0im      -0.5+0.0im      -0.5+0.0im       0.0+0.0im  -2.73205+0.0im       0.0+0.0im       0.0+0.0im      -0.5+0.0im       0.0+0.0im  0.732051+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.Flux2d-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{Tuple, AbstractVector}, T2<:Union{Tuple, AbstractVector}}","page":"Public","title":"TopologicalNumbers.Flux2d","text":"Hamiltonian of the two-dimensional square lattice with flux model.\n\n Flux2d(k::T1, p::T2) where {T1<:Union{AbstractVector,Tuple}, T2<:Union{AbstractVector,Tuple}}\n\nArguments\n\nk::T1: one-dimensional wavenumber k.\np::T2: parameters defined as below.\n\nDefinition\n\nHamiltonian of the two-dimensional square lattice with flux model is defined as\n\nH(k)=beginpmatrix\n    -2tcos(k_2-2pi mfrac1n)  -t                                0       0   cdots                                e^-ik_1           \n    -t                                -2tcos(k_2-2pi mfrac2n)  -t      0   cdots                                0                     \n    0                                 -t                                ddots  -t  cdots                                vdots                \n    vdots                            vdots                                    -t  -2tcos(k_2-2pi mfrac(n-1)n)  -t                    \n    e^ik_1                        0                                 cdots  0   -t                                    -2tcos(k_2-2pi m)\nendpmatrix\n\nwhere t is the amplitude of the nearest neighbor hopping in the tight binding model. n and m are the size of the unit cell of the phase produced by the application of the static magnetic field. Nondimensionalize with t=1 and nm=p.\n\nExamples\n\njulia> Flux2d([0, π/3], [4, 1])\n4×4 Matrix{ComplexF64}:\n -1.73205+0.0im  -1.0+0.0im      0.0+0.0im  -1.0+0.0im\n     -1.0+0.0im   1.0+0.0im     -1.0+0.0im   0.0+0.0im\n      0.0+0.0im  -1.0+0.0im  1.73205+0.0im  -1.0+0.0im\n     -1.0-0.0im   0.0+0.0im     -1.0+0.0im  -1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.Haldane-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{Tuple, AbstractVector}, T2<:Union{Tuple, AbstractVector}}","page":"Public","title":"TopologicalNumbers.Haldane","text":"Hamiltonian of the Haldane model.\n\n Haldane(k::T1, p::T2) where {T1<:Union{AbstractVector,Tuple}, T2<:Union{AbstractVector,Tuple}}\n\nArguments\n\nk::T1: two-dimensional wavenumber k.\np::T2: parameters defined as below.\n\nDefinition\n\nHamiltonian of the Haldane model is defined as\n\nH(bmk)=beginpmatrix\n    h_0(bmk)+h_3(bmk)   h_1(bmk)-ih_2(bmk) \n    h_1(bmk)+ih_2(bmk)  h_0(bmk)-h_3(bmk)\nendpmatrix\n\nbeginalign*\n     h_0(bmk)=2t_2cos(phi)(sin(k_1)+sin(k_2)+sin(k_1+k_2)) \n     h_1(bmk)=-t_1(1+cos(k_1)+cos(k_2)) \n     h_2(bmk)=-t_1(-sin(k_1)+sin(k_2)) \n     h_3(bmk)=m+2t_2sin(phi)(sin(k_1)+sin(k_2)-sin(k_1+k_2))\nendalign*\n\nwhere t_1 and t_2 are the amplitudes of the nearest and the next nearest neighbor hopping in the tight binding model. phi is the phase produced by the application of the static magnetic field. Nondimensionalize with t_1=1 and t_2phim=p.\n\nExamples\n\njulia> Haldane([0, π/3], [0.5, π/2, 0.3])\n2×2 Matrix{ComplexF64}:\n  0.3-0.0im       -2.5+0.866025im\n -2.5-0.866025im  -0.3-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.KaneMele-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{Tuple, AbstractVector}, T2<:Real}","page":"Public","title":"TopologicalNumbers.KaneMele","text":"Hamiltonian of the Kane–Mele model.\n\n KaneMele(k::T1, p::T2) where {T1<:Union{AbstractVector,Tuple}, T2<:Real}\n\nArguments\n\nk::T1: two-dimensional wavenumber k.\np::T2: parameter defined as below.\n\nDefinition\n\nHamiltonian of the Kane–Mele model is defined as\n\nH(k)=beginpmatrix\n    h_3(bmk)                 0                             h_5(bmk)-ih_4(bmk)  0                            \n    0                             -h_3(bmk)                0                             h_5(bmk)-ih_4(bmk) \n    h_5(bmk)+ih_4(bmk)  0                             -h_3(bmk)                0                            \n    0                             h_5(bmk)+ih_4(bmk)  0                             h_3(bmk)\nendpmatrix\n\nbeginalign*\n     h_3(bmk)=2lambda_mathrmSO(sin(k_1)-sin(k_2)-sin(k_1-k_2)) \n     h_4(bmk)=-t(sin(k_1)+sin(k_2)) \n     h_5(bmk)=-t(cos(k_1)+cos(k_2)+1)\nendalign*\n\nwhere t is the amplitude of the nearest neighbor hopping in the tight binding model. lambda_mathrmSO is the magnitude of spin-orbit interaction. Nondimensionalize with t=1 and lambda_mathrmSO=p.\n\nExamples\n\njulia> KaneMele([0, π/3], 0.5)\n4×4 Matrix{ComplexF64}:\n  0.0+0.0im        0.0+0.0im       -2.5+0.866025im   0.0+0.0im\n  0.0+0.0im        0.0+0.0im        0.0+0.0im       -2.5+0.866025im\n -2.5-0.866025im   0.0+0.0im        0.0+0.0im        0.0+0.0im\n  0.0+0.0im       -2.5-0.866025im   0.0+0.0im        0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.KitaevChain-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Real, T2<:Union{Tuple, AbstractVector}}","page":"Public","title":"TopologicalNumbers.KitaevChain","text":"Hamiltonian of the Kitaev chain model.\n\n KitaevChain(k::T1, p::T2) where {T1<:Real, T2<:Union{AbstractVector,Tuple}}\n\nArguments\n\nk::T1: one-dimensional wavenumber k.\np::T2: parameters defined as below.\n\nDefinition\n\nHamiltonian of the Kitaev chain model is defined as\n\nH(k)=beginpmatrix\n    -mu-2tcos(k)    2iDeltasin(k) \n    -2iDeltasin(k)  mu+2tcos(k)\nendpmatrix\n\nwhere t is the amplitude of the nearest neighbor hopping in the tight binding model. Delta is the pairing with the nearest neighbor site, mu is the chemical potential. Nondimensionalize with t=1 and muDelta=p.\n\nExamples\n\njulia> SSH(π/3, 0.5)\n2×2 Matrix{ComplexF64}:\n -0.5+0.0im       0.0+0.866025im\n  0.0-0.866025im  0.5+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.KitaevHoneycomb-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{Tuple, AbstractVector}, T2<:Real}","page":"Public","title":"TopologicalNumbers.KitaevHoneycomb","text":"Hamiltonian of the Kitaev honeycomb model.\n\n KitaevHoneycomb(k::T1, p::T2) where {T1<:Union{AbstractVector,Tuple}, T2<:Real}\n\nArguments\n\nk::T1: two-dimensional wavenumber k.\np::T2: parameter defined as below.\n\nDefinition\n\nHamiltonian of the Kitaev honeycomb model is defined as\n\nH(bmk)=beginpmatrix\n    h_3(bmk)                 h_1(bmk)-ih_2(bmk) \n    h_1(bmk)+ih_2(bmk)  -h_3(bmk)\nendpmatrix\n\nbeginalign*\n     h_1(bmk)=-K_2(sin(k_2)-sin(k_1)+sin(k_1-k_2)) \n     h_2(bmk)=-K_1(sin(k_1)+sin(k_2)) \n     h_3(bmk)=K_1(cos(k_1)+cos(k_2)+1)\nendalign*\n\nwhere K_1 is the magnitude of Kitaev interaction. K_2 is the magnitude of spin triples term due to magnetic field. Nondimensionalize with K_1=1 and K_2=p.\n\nExamples\n\njulia> KitaevHoneycomb([0, π/3], 0.5)\n2×2 Matrix{ComplexF64}:\n 2.5-0.0im        0.0+0.866025im\n 0.0-0.866025im  -2.5-0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.LatticeDirac-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{Tuple, AbstractVector}, T2<:Real}","page":"Public","title":"TopologicalNumbers.LatticeDirac","text":"Hamiltonian of the lattice Dirac model.\n\n LatticeDirac(k::T1, p::T2) where {T1<:Union{AbstractVector,Tuple},T2<:Real}\n\nArguments\n\nk::T1: four-dimensional wavenumber k.\np::T2: parameter defined as below.\n\nDefinition\n\nHamiltonian of the lattice Dirac model is defined as\n\nH(k)=beginpmatrix\n    h_4(bmk)                 h_2(bmk)-ih_3(bmk)  h_0(bmk)-ih_1(bmk)   0                             \n    h_2(bmk)+ih_3(bmk)  -h_4(bmk)                0                              h_0(bmk)-ih_1(bmk)  \n    h_0(bmk)+ih_1(bmk)  0                             -h_4(bmk)                 -h_2(bmk)+ih_3(bmk) \n    0                             h_0(bmk)+ih_1(bmk)  -h_2(bmk)-ih_3(bmk)  h_4(bmk)\nendpmatrix\n\nbeginalign*\n     h_0(bmk)=m+c(cos(k_1)+cos(k_2)+cos(k_3)+cos(k_4)) \n     h_1(bmk)=sin(k_1) \n     h_2(bmk)=sin(k_2) \n     h_3(bmk)=sin(k_3) \n     h_4(bmk)=sin(k_4)\nendalign*\n\nwhere,,,\n\nExamples\n\n```julia julia> LatticeDirac([0, 0, 0, π/2], 0.5) 4×4 Matrix{ComplexF64}:  1.0+0.0im   0.0+0.0im   3.5+0.0im  0.0+0.0im  0.0+0.0im  -1.0+0.0im   0.0+0.0im  3.5+0.0im  3.5+0.0im   0.0+0.0im  -1.0+0.0im  0.0+0.0im  0.0+0.0im   3.5+0.0im   0.0+0.0im  1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.SSH-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Real, T2<:Real}","page":"Public","title":"TopologicalNumbers.SSH","text":"Hamiltonian of the Su-Schrieffer-Heeger model.\n\n SSH(k::T1, p::T2) where {T1<:Real,T2<:Real}\n\nArguments\n\nk::T1: one-dimensional wavenumber k.\np::T2: parameter defined as below.\n\nDefinition\n\nHamiltonian of the Su-Schrieffer-Heeger model is defined as\n\nH(k)=beginpmatrix\n    0                  t_1+t_2e^-ik \n    t_1+t_2e^ik  0\nendpmatrix\n\nwhere t_1 and t_2 are the amplitudes of the nearest neighbor hopping in the tight binding model. Nondimensionalize with t_1=1 and t_2=p.\n\nExamples\n\njulia> SSH(π/3, 0.5)\n2×2 Matrix{ComplexF64}:\n  0.0+0.0im       1.25-0.433013im\n 1.25+0.433013im   0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.ThoulessPump-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{Tuple, AbstractVector}, T2<:Union{Tuple, AbstractVector}}","page":"Public","title":"TopologicalNumbers.ThoulessPump","text":"Hamiltonian of the Thouless pumping model.\n\n ThoulessPump(k::T1, p::T2) where {T1<:Union{AbstractVector,Tuple}, T2<:Union{AbstractVector,Tuple}}\n\nArguments\n\nk::T1: two-dimensional wavenumber k.\np::T2: parameters defined as below.\n\nDefinition\n\nHamiltonian of the Thouless pumping model is defined as\n\nH(k)=\n\nwhere,,,\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcBerryFlux-Tuple{Function, Vector{Int64}}","page":"Public","title":"TopologicalNumbers.calcBerryFlux","text":"Calculate the Berry flux in the two-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\ncalcBerryFlux(Hamiltonian::Function, n::Vector{Int64}; N::Int=51, gapless::Real=0.0, rounds::Bool=true)\n\nArguments\n\nHamiltionian::Function: the Hamiltonian matrix with one-dimensional wavenumber k as an argument.\nn::Vector{Int64}: The wavenumber(2pi nN) when calculating Berry flux.\nN::Int=51: The number of meshes when discretizing the Brillouin Zone. It is preferable for N to be an odd number to increase the accuracy of the calculation.\ngapless::Real: The threshold that determines the state to be degenerate. Coarsening the mesh(N) but increasing gapless will increase the accuracy of the calculation.\nrounds::Bool=true: An option to round the value of the topological number to an integer value. The topological number returns a value of type Int when true, and a value of type Float when false.\n\nDefinition\n\nThe Berry flux at the wavenumber bmk of the nth band F_n(bmk) is defined by\n\nF_n(bmk)=f_n(bmk)-df_n(bmk)\n\nf_n(bmk)=frac12pimathrmImleftmathrmLogleftU_n1(bmk)U_n2(bmk+bme_1)U_n1^*(bmk+bme_2)U_n1^*(bmk)rightright\n\ndf_n(bmk)=frac12pimathrmImleftmathrmLogU_n1(bmk)+mathrmLogU_n2(bmk+bme_1)-mathrmLogU_n1(bmk+bme_2)-mathrmLogU_n1(bmk)right\n\nU_ni(bmk) is the link variable at wavenumber bmk. bme_i is the unit vector.\n\nU_ni(bmk)=braketPsi_n(bmk)Psi_n(bmk+bme_i)\n\nketPsi_n(bmk) is the wave function of the nth band.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcBerryPhase-Tuple{Function}","page":"Public","title":"TopologicalNumbers.calcBerryPhase","text":"Calculate the winding numbers in the one-dimensional case.\n\ncalcBerryPhase(Hamiltonian::Function; N::Int=51, gapless::Real=0.0, rounds::Bool=true)\n\nArguments\n\nHamiltonian::Function: the Hamiltonian matrix function with one-dimensional wavenumber k as an argument.\nN::Int: the number of meshes when discretizing the Brillouin Zone. It is preferable for N to be an odd number to increase the accuracy of the calculation.\ngapless::Real: the threshold that determines the state to be degenerate. Coarsening the mesh(N) but increasing gapless will increase the accuracy of the calculation.\nrounds::Bool: an option to round the value of the topological number to an integer value. The topological number returns a value of type Int when true, and a value of type Float when false.\n\nDefinition\n\nThe Berry phase of the nth band nu_n is defined by\n\nnu_n=frac1pisum_kinmathrmBZU_n(k)\n\nThe range mathrmBZ(Brillouin Zone) is kin02pi. U_ni(k) is the link variable at wavenumber k. e_1 is the unit vector.\n\nU_n(k)=braketPsi_n(k)Psi_n(k+e_1)\n\nketPsi_n(k) is the wave function of the nth band.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcChern-Tuple{Function}","page":"Public","title":"TopologicalNumbers.calcChern","text":"Calculate the first Chern numbers in the two-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\ncalcChern(Hamiltonian::Function; N::Int=51, gapless::Real=0.0, rounds::Bool=true)\n\nArguments\n\nHamiltionian::Function: The Hamiltonian matrix with two-dimensional wavenumber k as an argument.\nN::Int=51: The number of meshes when discretizing the Brillouin Zone. It is preferable for N to be an odd number to increase the accuracy of the calculation.\ngapless::Real: The threshold that determines the state to be degenerate. Coarsening the mesh(N) but increasing gapless will increase the accuracy of the calculation.\nrounds::Bool=true: An option to round the value of the topological number to an integer value. The topological number returns a value of type Int when true, and a value of type Float when false.\n\nDefinition\n\nThe first Chern number of the nth band nu_n is defined by\n\nnu_n=frac12pisum_bmkinmathrmBZmathrmImleftmathrmLogleftU_n1(bmk)U_n2(bmk+bme_1)U_n1^*(bmk+bme_2)U_n2^*(bmk)rightright\n\nThe range mathrmBZ(Brillouin Zone) is bmkin02pi^2. U_ni(bmk) is the link variable at wavenumber bmk. bme_i is the unit vector.\n\nU_ni(bmk)=braketPsi_n(bmk)Psi_n(bmk+bme_i)\n\nketPsi_n(bmk) is the wave function of the nth band.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcChernSurface-Union{Tuple{T}, Tuple{Function, String}} where T<:TopologicalNumbers.TopologicalNumbersParallel","page":"Public","title":"TopologicalNumbers.calcChernSurface","text":"calcChernSurface(H::Function, kn::String; kn_mesh::Int=51, N::Int=51, gapless::Real=0.0, rounds::Bool=true, plot::Bool=false)\n\nArguments\n\nHamiltionian::Function: The Hamiltonian matrix with three-dimensional wavenumber k as an argument.\nkn::String: Compute the Chern number of the plane perpendicular to the \"kn\" direction in Brillouin zone (\"k1\", \"k2\", \"k3\").\nkn_mesh::T: Number of mesh in \"kn\" direction.\nN::Int=51: The number of meshes when discretizing the Brillouin Zone. It is preferable for N to be an odd number to increase the accuracy of the calculation.\ngapless::Real: The threshold that determines the state to be degenerate. Coarsening the mesh(N) but increasing gapless will increase the accuracy of the calculation.\nrounds::Bool=true: An option to round the value of the topological number to an integer value. The topological number returns a value of type Int when true, and a value of type Float when false.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{BPProblem, T1}, Tuple{BPProblem, T1, T2}} where {T1<:(AbstractVector), T2<:TopologicalNumbers.BerryPhaseAlgorithms, T3<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::BPProblem, param_range::T1, alg::T2=BP(); parallel::T3=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:BerryPhaseAlgorithms,T3<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{FCProblem, T1}, Tuple{FCProblem, T1, T2}} where {T1<:(AbstractVector), T2<:TopologicalNumbers.FirstChernAlgorithms, T3<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::FCProblem, param_range::T1, alg::T2=FHS(); parallel::T3=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:FirstChernAlgorithms,T3<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{SCProblem, T1}, Tuple{SCProblem, T1, T2}} where {T1<:(AbstractVector), T2<:TopologicalNumbers.SecondChernAlgorithms, T3<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::SCProblem, param_range::T1, alg::T2=FHS2(); parallel::T3=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:SecondChernAlgorithms,T3<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Z2Problem, T1}, Tuple{Z2Problem, T1, T2}} where {T1<:(AbstractVector), T2<:TopologicalNumbers.Z2Algorithms, T3<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::Z2Problem, param_range::T1, alg::T2=Shio(); parallel::T3=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:Z2Algorithms,T3<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{BPProblem, T1, T2}, Tuple{BPProblem, T1, T2, T3}} where {T1<:(AbstractVector), T2<:(AbstractVector), T3<:TopologicalNumbers.BerryPhaseAlgorithms, T4<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::BPProblem, param_range1::T1, param_range2::T2, alg::T3=BP(); parallel::T4=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:AbstractVector,T3<:BerryPhaseAlgorithms,T4<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{FCProblem, T1, T2}, Tuple{FCProblem, T1, T2, T3}} where {T1<:(AbstractVector), T2<:(AbstractVector), T3<:TopologicalNumbers.FirstChernAlgorithms, T4<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::FCProblem, param_range1::T1, param_range2::T2, alg::T3=FHS(); parallel::T4=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:AbstractVector,T3<:FirstChernAlgorithms,T4<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2}} where {T1<:(AbstractVector), T2<:Union{String, TopologicalNumbers.TopologicalNumbersAlgorithms}, T3<:Union{Int64, Tuple, AbstractVector}, T4<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(H::Function, param_range::T1, alg::T2; N::T3=51, parallel::T4=UseSingleThread(), gapless::Real=0.0, rounds::Bool=true, plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:Union{String,TopologicalNumbersAlgorithms},T3<:Union{Int,Tuple,AbstractVector},T4<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{SCProblem, T1, T2}, Tuple{SCProblem, T1, T2, T3}} where {T1<:(AbstractVector), T2<:(AbstractVector), T3<:TopologicalNumbers.SecondChernAlgorithms, T4<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::SCProblem, param_range1::T1, param_range2::T2, alg::T3=FHS2(); parallel::T4=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:AbstractVector,T3<:SecondChernAlgorithms,T4<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Z2Problem, T1, T2}, Tuple{Z2Problem, T1, T2, T3}} where {T1<:(AbstractVector), T2<:(AbstractVector), T3<:TopologicalNumbers.Z2Algorithms, T4<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(prob::Z2Problem, param_range1::T1, param_range2::T2, alg::T3=Shio(); parallel::T4=UseSingleThread(), plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:AbstractVector,T3<:Z2Algorithms,T4<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcPhaseDiagram-Union{Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Function, T1, T2, T3}} where {T1<:(AbstractVector), T2<:(AbstractVector), T3<:Union{String, TopologicalNumbers.TopologicalNumbersAlgorithms}, T4<:Union{Int64, Tuple, AbstractVector}, T5<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcPhaseDiagram","text":"calcPhaseDiagram(H::Function, param_range1::T1, param_range2::T2, alg::T3; N::T4=51, parallel::T5=UseSingleThread(), gapless::Real=0.0, rounds::Bool=true, plot::Bool=false, progress::Bool=false) where {T1<:AbstractVector,T2<:AbstractVector,T3<:Union{String,TopologicalNumbersAlgorithms},T4<:Union{Int,Tuple,AbstractVector},T5<:TopologicalNumbersParallel}\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcSecondChern-Union{Tuple{Function}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where {T1<:Union{Nothing, Int64}, T2<:Union{Tuple, AbstractVector}, T3<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.calcSecondChern","text":"Calculate the second Chern numbers in the four-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1, 2].\n\ncalcSecondChern(Hamiltonian::Function; Nfill::T1=nothing, N::T2=(30, 30, 30, 30), returnRealValue::Bool=true, parallel::T3=UseSingleThread()) where {T1<:Union{Int,Nothing},T2<:Union{AbstractVector,Tuple},T3<:TopologicalNumbersParallel}\n\nArguments\n\nHamiltionian: The Hamiltonian matrix with two-dimensional wavenumber k as an argument.\nNfill::T1: The filling number. The default value is Hs ÷ 2, where Hs is the size of the Hamiltonian matrix.\nN::T2: The numbers of meshes when discretizing the Brillouin Zone. Each element of N is the number of meshes in the x, y, z, and w directions, respectively.\nreturnRealValue::Bool: An option to return the value of the topological number by an real value. The topological number returns a value of type Float64 when true, and a value of type ComplexF64 when false.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcWeylNode-Union{Tuple{T}, Tuple{Function, T}} where T<:AbstractVector{Int64}","page":"Public","title":"TopologicalNumbers.calcWeylNode","text":"Calculate the Weyl node in the three-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\ncalcWeylNode(Hamiltonian::Function, n::Vector{Int64}; N::Int=51, gapless::Real=0.0, rounds::Bool=true)\n\nArguments\n\nHamiltionian::Function: the Hamiltonian matrix with three-dimensional wavenumber k as an argument.\nn::Vector{Int64}: The wavenumber(2pibmnN) when calculating Weyl node.\nN::Int=51: The number of meshes when discretizing the Brillouin Zone. It is preferable for N to be an odd number to increase the accuracy of the calculation.\ngapless::Real: The threshold that determines the state to be degenerate. Coarsening the mesh(N) but increasing gapless will increase the accuracy of the calculation.\nrounds::Bool=true: An option to round the value of the topological number to an integer value. The topological number returns a value of type Int when true, and a value of type Float when false.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.calcZ2-Tuple{Function}","page":"Public","title":"TopologicalNumbers.calcZ2","text":"Calculate the mathbbZ_2 numbers in the two-dimensional case with reference to Shiozaki method [3, 4].\n\ncalcZ2(Hamiltonian::Function; N::Int=50, rounds::Bool=true, TR::Bool=false)\n\nArguments\n\nHamiltonian::Function is a matrix with one-dimensional wavenumber k as an argument.\nN::Int is the number of meshes when discretizing the Brillouin Zone. It is preferable for N to be an odd number to increase the accuracy of the calculation.\nrounds::Bool is an option to round the value of the topological number to an integer value. The topological number returns a value of type Int when true, and a value of type Float when false.\n\nDefinition\n\nThe mathbbZ_2 number of the 2nth (and 2n-1th) band nu_n is defined by\n\nnu_n=F_n-left(P_n(0)-P_n(pi)right)\n\nF_n is the Berry flux of the nth band in the mathrmBZ. The range mathrmBZ is bmkin02pitimes0pi half of BZ(Brillouin Zone).\n\nF_n=frac12pisum_bmkinmathrmBZmathrmImleftmathrmLogleftU_n1(bmk)U_n2(bmk+bme_1)U_n1^*(bmk+bme_2)U_n1^*(bmk)rightright\n\nP_n(k_2) is the time-reversal polarization at wavenumber k_2.\n\nP_n(k_2)=frac12pifracmathrmPfomega(0k_2)mathrmPfomega(pik_2)sum_k_1=0^pi-e_1U_n1(bmk)\n\nU_ni(bmk) is the link variable at wavenumber bmk. bme_i is the unit vector.\n\nU_ni(bmk)=braketPsi_n(bmk)Psi_n(bmk+bme_i)\n\nketPsi_n(bmk) is the wave function of the 2nth (and 2n-1th) band. omega(bmk) is the unitary matrix given by\n\nomega(bmk)=braPsi(-bmk)TketPsi(bmk)\n\nT is the time-reversal operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.findWeylPoint-Union{Tuple{Function}, Tuple{T}} where T<:AbstractVector{Float64}","page":"Public","title":"TopologicalNumbers.findWeylPoint","text":"findWeylPoint(Hamiltonian::Function; N::Int=10, gapless::T=[1e-1, 1e-2, 1e-3, 1e-4], rounds::Bool=true) where {T<:AbstractVector{Float64}}\n\nArguments\n\nHamiltionian::Function: The Hamiltonian matrix with three-dimensional wavenumber k as an argument.\nN::Int=10: The number of meshes when discretizing the Brillouin Zone. The nth iteration divides the Brillouin zone into 1N^n.\ngapless<:AbstractVector{Float64}: The threshold that determines the state to be degenerate. The nth iteration adopts the threshold value of the nth value of the vector. The number of iterations can be varied by the length of the vector.\nrounds::Bool=true: An option to round the value of the topological number to an integer value. The topological number returns a value of type Int when true, and a value of type Float when false.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.plot1D-Tuple{NamedTuple}","page":"Public","title":"TopologicalNumbers.plot1D","text":"plot1D(result::NamedTuple; labels::Bool=true, disp::Bool=true, png::Bool=false, pdf::Bool=false, svg::Bool=false, filename::String=\"phaseDiagram\")\n\nPlot a 1D phase diagram.\n\nArguments\n\nresult::NamedTuple: A named tuple containing the result data.\nlabels::Bool=true: Whether to display axis labels.\ndisp::Bool=true: Whether to display the plot.\npng::Bool=false: Whether to save the plot as a PNG file.\npdf::Bool=false: Whether to save the plot as a PDF file.\nsvg::Bool=false: Whether to save the plot as an SVG file.\nfilename::String=\"phaseDiagram\": The filename for the saved plot.\n\nReturns\n\nfig: The matplotlib figure object.\n\nExample\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.plot1D-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Union{AbstractMatrix, AbstractVector}, T2<:(AbstractVector)}","page":"Public","title":"TopologicalNumbers.plot1D","text":"plot1D(nums::T1, param_range::T2; labels::Bool=true, disp::Bool=true, png::Bool=false, pdf::Bool=false, svg::Bool=false, filename::String=\"phaseDiagram\") where {T1<:AbstractMatrix,T2<:AbstractVector}\n\nPlot a 1D phase diagram.\n\nArguments\n\nnums::T1: A matrix or vector containing the data to be plotted.\nparam_range::T2: A vector representing the parameter range.\nlabels::Bool=true: Whether to display axis labels. Default is true.\ndisp::Bool=true: Whether to display the plot. Default is true.\npng::Bool=false: Whether to save the plot as a PNG file. Default is false.\npdf::Bool=false: Whether to save the plot as a PDF file. Default is false.\nsvg::Bool=false: Whether to save the plot as an SVG file. Default is false.\nfilename::String=\"phaseDiagram\": The filename for the saved plot. Default is \"phaseDiagram\".\n\nExamples\n\nnums = [1 2 3; 4 5 6]\nparam_range = [0.1, 0.2, 0.3]\nplot1D(nums, param_range)\n\nReturns\n\nfig: The matplotlib figure object representing the plot.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.plot1D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:TopologicalNumbers.SecondChernAlgorithms, T2<:(AbstractVector), T3<:(AbstractVector)}","page":"Public","title":"TopologicalNumbers.plot1D","text":"plot1D(::T1, nums::T2, param_range::T3; labels::Bool=true, disp::Bool=true, png::Bool=false, pdf::Bool=false, svg::Bool=false, filename::String=\"phaseDiagram\") where {T1<:SecondChernAlgorithms,T2<:AbstractVector,T3<:AbstractVector}\n\nPlot a 1D phase diagram.\n\nArguments\n\n::T1: An object of type T1 that implements the SecondChernAlgorithms interface.\nnums::T2: A vector of numbers representing the values to be plotted.\nparam_range::T3: A vector representing the parameter range.\nlabels::Bool=true: Whether to display labels on the plot. Default is true.\ndisp::Bool=true: Whether to display the plot. Default is true.\npng::Bool=false: Whether to save the plot as a PNG file. Default is false.\npdf::Bool=false: Whether to save the plot as a PDF file. Default is false.\nsvg::Bool=false: Whether to save the plot as an SVG file. Default is false.\nfilename::String=\"phaseDiagram\": The filename for the saved plot. Default is \"phaseDiagram\".\n\nExamples\n\nplot1D(obj, nums, param_range)\n\nReturns\n\nfig: The matplotlib figure object representing the plot.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.plot2D-Tuple{NamedTuple}","page":"Public","title":"TopologicalNumbers.plot2D","text":"plot2D(result::NamedTuple; labels::Bool=true, disp::Bool=true, png::Bool=false, pdf::Bool=false, svg::Bool=false, filename::String=\"phaseDiagram\")\n\nPlot a 2D phase diagram.\n\nArguments\n\nresult::NamedTuple: A named tuple containing the result data.\nlabels::Bool=true: Whether to display axis labels.\ndisp::Bool=true: Whether to display the plot.\npng::Bool=false: Whether to save the plot as a PNG file.\npdf::Bool=false: Whether to save the plot as a PDF file.\nsvg::Bool=false: Whether to save the plot as an SVG file.\nfilename::String=\"phaseDiagram\": The filename for the saved plot.\n\nReturns\n\nfig: The matplotlib figure object.\n\nExample\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.plot2D-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:AbstractArray, T2<:(AbstractVector), T3<:(AbstractVector)}","page":"Public","title":"TopologicalNumbers.plot2D","text":"plot2D(nums::T1, param_range1::T2, param_range2::T3; labels::Bool=true, disp::Bool=true, png::Bool=false, pdf::Bool=false, svg::Bool=false, filename::String=\"phaseDiagram\") where {T1<:AbstractArray,T2<:AbstractVector,T3<:AbstractVector}\n\nPlot a 2D phase diagram.\n\nArguments\n\nnums::T1: An array of numbers representing the phase diagram.\nparam_range1::T2: A vector representing the range of the first parameter.\nparam_range2::T3: A vector representing the range of the second parameter.\nlabels::Bool=true: Whether to display axis labels. Default is true.\ndisp::Bool=true: Whether to display the plot. Default is true.\npng::Bool=false: Whether to save the plot as a PNG file. Default is false.\npdf::Bool=false: Whether to save the plot as a PDF file. Default is false.\nsvg::Bool=false: Whether to save the plot as an SVG file. Default is false.\nfilename::String=\"phaseDiagram\": The filename for the saved plot. Default is \"phaseDiagram\".\n\nReturns\n\nfig: The matplotlib figure object.\n\nExample\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.showBand-Tuple{Function}","page":"Public","title":"TopologicalNumbers.showBand","text":"showBand(Hamiltonian::Function; N::Int=51, labels::Bool=true, value::Bool=true, disp::Bool=false, png::Bool=false, pdf::Bool=false, svg::Bool=false, filename::String=\"Band\")\n\nThis function generates a band structure plot for a given Hamiltonian.\n\nArguments\n\nHamiltonian::Function: The Hamiltonian function that takes a wave number parameter k and returns the corresponding Hamiltonian matrix.\nN::Int: The number of points in the Brillouin zone. Default is 51.\nlabels::Bool: Whether to display the labels of the figure. Default is true.\nvalue::Bool: Whether to output the values of the wave number and the energy in the matrix form. Default is true.\ndisp::Bool: Whether to display the plot. Default is false.\npng::Bool: Whether to save the plot as a PNG file. Default is false.\npdf::Bool: Whether to save the plot as a PDF file. Default is false.\nsvg::Bool: Whether to save the plot as an SVG file. Default is false.\nfilename::String: The filename for the saved plot. Default is \"Band\".\n\nExamples\n\njulia> H(k) = SSH(k, (0.9, 1.0)) # $N \\times N$ Hamiltonian matrix with a wavenumber parameter k\njulia> showBand(H)\n(k = -3.141592653589793:0.12566370614359174:3.141592653589793, Ene = [-0.09999999999999998 0.09999999999999998; -0.15554271964299698 0.15554271964299698; … ; -0.15554271964299698 0.15554271964299698; -0.09999999999999998 0.09999999999999998])\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{BPProblem}, Tuple{T2}, Tuple{T1}, Tuple{BPProblem, T1}} where {T1<:TopologicalNumbers.BerryPhaseAlgorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the winding numbers in the one-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\nsolve(prob::BPProblem, alg::T1=BP(); parallel::T2=UseSingleThread()) where {T1<:BerryPhaseAlgorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::BPProblem: The BPProblem struct that contains the Hamiltonian matrix function in the wave number space and other parameters.\nalg::T1=BP(): The algorithm to use for calculating the Berry phases. Default is BP algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nBPSolution: A struct that contains the calculated Berry phases.\n\nExamples\n\njulia> H(k) = SSH(k, 1.1)\njulia> prob = BPProblem(H)\njulia> result = solve(prob)\nBPSolution{Vector{Int64}, Int64}([1, 1], 0)\njulia> result.TopologicalNumber\n2-element Vector{Int64}:\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{FCProblem}, Tuple{T2}, Tuple{T1}, Tuple{FCProblem, T1}} where {T1<:TopologicalNumbers.FirstChernAlgorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the first Chern numbers in the two-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\nsolve(prob::FCProblem, alg::T1=FHS(); parallel::T2=UseSingleThread()) where {T1<:FirstChernAlgorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::FCProblem: The FCProblem struct that contains the Hamiltonian matrix function in the wave number space and other parameters.\nalg::T1=FHS(): The algorithm to use for calculating the first Chern numbers. Default is FHS algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nFCSolution: A struct that contains the calculated first Chern numbers.\n\nExamples\n\njulia> H(k) = Haldane(k, (1, 0.5, 1.0))\njulia> prob = FCProblem(H)\njulia> result = solve(prob)\nFCSolution{Vector{Int64}, Int64}([1, -1], 0)\njulia> result.TopologicalNumber\n2-element Vector{Int64}:\n  1\n -1\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{LBFProblem}, Tuple{T2}, Tuple{T1}, Tuple{LBFProblem, T1}} where {T1<:TopologicalNumbers.BerryFluxAlgorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the Berry flux in the two-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\nsolve(prob::LBFProblem, alg::T1=FHSlocal2(); parallel::T2=UseSingleThread()) where {T1<:BerryFluxAlgorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::LBFProblem: The LBFProblem struct that contains the Hamiltonian matrix function in the wave number space and other parameters.\nalg::T1=FHSlocal2(): The algorithm to use for calculating the second Chern numbers. Default is FHSlocal2 algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nLBFSolution: A struct that contains the calculated Berry flux.\n\nExamples\n\njulia> H(k) = Flux2d(k, (6, 1))\njulia> n = [0, 0]\njulia> prob = LBFProblem(H, n)\njulia> result = solve(prob)\nLBFSolution{Vector{Int64}, Vector{Int64}}([0, 0, 0, 0, -1, 0], [0, 0])\njulia> result.TopologicalNumber\n6-element Vector{Int64}:\n  0\n  0\n  0\n  0\n -1\n  0\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{SCProblem}, Tuple{T2}, Tuple{T1}, Tuple{SCProblem, T1}} where {T1<:TopologicalNumbers.SecondChernAlgorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the second Chern numbers in the four-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1, 2].\n\nsolve(prob::SCProblem, alg::T1=FHS2(); parallel::T2=UseSingleThread()) where {T1<:SecondChernAlgorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::SCProblem: The SCProblem struct that contains the Hamiltonian matrix function in the wave number space, filling number, mesh numbers, and other parameters.\nalg::T1=FHS2(): The algorithm to use for calculating the second Chern numbers. Default is FHS2 algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nSCSolution: A struct that contains the calculated second Chern numbers.\n\nExamples\n\njulia> H(k) = LatticeDirac(k, -3.0)\njulia> prob = SCProblem(H)\njulia> result = solve(prob)\nSCSolution{Float64}(0.9793607631927381)\njulia> result.TopologicalNumber\n0.9793607631927381\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{WCSProblem}, Tuple{T2}, Tuple{T1}, Tuple{WCSProblem, T1}} where {T1<:TopologicalNumbers.WeylPointsAlgorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the sliced first Chern numbers in the three-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\nsolve(prob::WCSProblem, alg::T1=FHSsurface(); parallel::T2=UseSingleThread()) where {T1<:WeylPointsAlgorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::WCSProblem: The WCSProblem struct that contains the Hamiltonian matrix function in the wave number space and other parameters.\nalg::T1=FHSsurface(): The algorithm to use for calculating the sliced first Chern numbers. Default is FHSsurface algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nWCSSolution: A struct that contains the calculated sliced first Chern numbers.\n\nExamples\n\njulia> function H₀(k, p) # Weyl\n    k1, k2, k3 = k\n    t1, t2, t3, m, k0 = p\n\n    h0 = 0\n    hx = 2t1*(cos(k1) - cos(k0)) + m*(2 - cos(k2) - cos(k3))\n    hy = 2t2*sin(k2)\n    hz = 2t3*sin(k3)\n\n    s0 = [1 0; 0 1]\n    sx = [0 1; 1 0]\n    sy = [0 -im; im 0]\n    sz = [1 0; 0 -1]\n\n    h0 .* s0 .+ hx .* sx .+ hy .* sy .+ hz .* sz\nend\njulia> p0 = (1, 1, 1, 2, 2pi*2/5);\njulia> H(k) = H₀(k, p0);\njulia> prob = WCSProblem(H, \"k1\");\njulia> sol = solve(prob)\nWCSSolution{String, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Matrix{Int64}}(\"k1\", 6.283185307179587e-5:0.12319971190548208:6.160048427127176, [0 0; 0 0; … ; 0 0; 0 0])\njulia> sol.nums\n51×2 Matrix{Int64}:\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{WNProblem}, Tuple{T2}, Tuple{T1}, Tuple{WNProblem, T1}} where {T1<:TopologicalNumbers.WeylPointsAlgorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the Weyl node in the three-dimensional case with reference to Fukui-Hatsugai-Suzuki method [1].\n\nsolve(prob::WNProblem, alg::T1=FHSlocal3(); parallel::T2=UseSingleThread()) where {T1<:WeylPointsAlgorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::WNProblem: The WNProblem struct that contains the Hamiltonian matrix function in the wave number space and other parameters.\nalg::T1=FHSlocal3(): The algorithm to use for calculating the Weyl nodes. Default is FHSlocal3 algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nWNSolution: A struct that contains the calculated Weyl nodes.\n\nExamples\n\njulia> function H₀(k, p) # Weyl\n    k1, k2, k3 = k\n    t1, t2, t3, m, k0 = p\n\n    h0 = 0\n    hx = 2t1*(cos(k1) - cos(k0)) + m*(2 - cos(k2) - cos(k3))\n    hy = 2t2*sin(k2)\n    hz = 2t3*sin(k3)\n\n    s0 = [1 0; 0 1]\n    sx = [0 1; 1 0]\n    sy = [0 -im; im 0]\n    sz = [1 0; 0 -1]\n\n    h0 .* s0 .+ hx .* sx .+ hy .* sy .+ hz .* sz\nend\njulia> p0 = (1, 1, 1, 2, 2pi*2/5);\njulia> H(k) = H₀(k .- 2pi*1e-5, p0);\njulia> weylPoint = [4000, 0, 0];\njulia> N = 10000;\njulia> prob = WNProblem(H, weylPoint, N);\njulia> sol = solve(prob)\nWNSolution{Vector{Int64}, Vector{Int64}, Int64}([1, -1], [4000, 0, 0], 10000)\njulia> sol.TopologicalNumber\n2-element Vector{Int64}:\n  1\n -1\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{WPProblem}, Tuple{T2}, Tuple{T1}, Tuple{WPProblem, T1}} where {T1<:TopologicalNumbers.WeylPointsAlgorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the Weyl points in the three-dimensional case using energy variational method.\n\nsolve(prob::WPProblem, alg::T1=Evar(); parallel::T2=UseSingleThread()) where {T1<:WeylPointsAlgorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::WPProblem: The WPProblem struct that contains the Hamiltonian matrix function in the wave number space and other parameters.\nalg::T1=Evar(): The algorithm to use for calculating the Weyl points. Default is Evar algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nWPSolution: A struct that contains the calculated Weyl points.\n\nExamples\n\njulia> function H₀(k, p) # Weyl\n    k1, k2, k3 = k\n    t1, t2, t3, m, k0 = p\n\n    h0 = 0\n    hx = 2t1*(cos(k1) - cos(k0)) + m*(2 - cos(k2) - cos(k3))\n    hy = 2t2*sin(k2)\n    hz = 2t3*sin(k3)\n\n    s0 = [1 0; 0 1]\n    sx = [0 1; 1 0]\n    sy = [0 -im; im 0]\n    sz = [1 0; 0 -1]\n\n    h0 .* s0 .+ hx .* sx .+ hy .* sy .+ hz .* sz\nend\njulia> p0 = (1, 1, 1, 2, 2pi*2/5);\njulia> H(k) = H₀(k, p0);\njulia> prob = WPProblem(H)\njulia> result = solve(prob)\nWPSolution{Vector{Vector{Vector{Int64}}}, Int64, Vector{Vector{Int64}}}([[[4000, 0, 0], [6000, 0, 0]], [[4000, 0, 0], [6000, 0, 0]]], 10000, [[1, -1], [-1, 1]])\njulia> 2pi*result.WeylPoint[1] / result.N .- pi*[ones(3), ones(3)]\n2-element Vector{Vector{Float64}}:\n [-0.6283185307179586, -3.141592653589793, -3.141592653589793]\n [0.6283185307179586, -3.141592653589793, -3.141592653589793]\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#TopologicalNumbers.solve-Union{Tuple{Z2Problem}, Tuple{T2}, Tuple{T1}, Tuple{Z2Problem, T1}} where {T1<:TopologicalNumbers.Z2Algorithms, T2<:TopologicalNumbers.TopologicalNumbersParallel}","page":"Public","title":"TopologicalNumbers.solve","text":"Calculate the mathbbZ_2 numbers in the two-dimensional case with reference to Shiozaki method [3, 4].\n\nsolve(prob::Z2Problem, alg::T1=Shio(); parallel::T2=UseSingleThread()) where {T1<:Z2Algorithms,T2<:TopologicalNumbersParallel}\n\nArguments\n\nprob::Z2Problem: The Z2Problem struct that contains the Hamiltonian matrix function in the wave number space and other parameters.\nalg::T1=Shio(): The algorithm to use for calculating the Z2 numbers. Default is Shio algorithm.\nparallel::T2=UseSingleThread(): The parallelization strategy to use. Default is to use a single thread.\n\nReturns\n\nZ2Solution: A struct that contains the calculated Z2 numbers.\n\nExamples\n\njulia> H(k) = KaneMele(k, 1.0)\njulia> prob = Z2Problem(H)\njulia> result = solve(prob)\nZ2Solution{Vector{Int64}, Nothing, Int64}([1, 1], nothing, 0)\njulia> result.TopologicalNumber\n2-element Vector{Int64}:\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"examples_old/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples_old/#One-dimensional-case","page":"Examples","title":"One-dimensional case","text":"","category":"section"},{"location":"examples_old/#The-Su-Schriffer-Heeger-(SSH)-model","page":"Examples","title":"The Su-Schriffer-Heeger (SSH) model","text":"","category":"section"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"Here's a simple example of the SSH Hamiltonian:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> using TopologicalNumbers\njulia> function H(k) # set SSH Hamiltonian function of wavenumber k\n    g = 0.9\n    \n    [\n        0 g+exp(-im*k)\n        g+exp(im*k) 0\n    ]\nend","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"The band structure is computed as follows:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> showBand(H; value=false, disp=true)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(Image: Band structure of SSH model)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"In this case, 1 signifies the dimension of the wavenumber space.","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"Next, we can calculate the winding numbers using calcBerryPhase:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> calcBerryPhase(H)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"The output is:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(TopologicalNumber = [1, 1], Total = 0)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the winding number for each band.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the winding numbers for each band (mod 2). Total is a quantity that should always return zero.","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> function H0(k, p)\n            [\n                0 p[1]+p[2]*exp(-im * k)\n                p[1]+p[2]*exp(im * k) 0\n            ]\n        end\njulia> H(k, p) = H0(k, (p, 1.0))\n\njulia> param = range(-2.0, 2.0, length=1001)\njulia> calcPhaseDiagram(H, param, \"BerryPhase\"; plot=true)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(Image: One-dimensional phase diagram of SSH model)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"Also, two-dimensional phase diagram is given by:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> param = range(-2.0, 2.0, length=101)\njulia> calcPhaseDiagram(H0, param, param, \"BerryPhase\"; plot=true)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(Image: Two-dimensional phase diagram of SSH model)","category":"page"},{"location":"examples_old/#Chern-numbers","page":"Examples","title":"Chern numbers","text":"","category":"section"},{"location":"examples_old/#Two-dimensional-square-lattice-with-flux-model","page":"Examples","title":"Two-dimensional square lattice with flux model","text":"","category":"section"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"A two-dimensional example is presented here:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> function H(k) # landau\n    k1, k2 = k\n    t = 1\n\n    Hsize = 6\n    Hmat = zeros(ComplexF64, Hsize, Hsize)\n\n    for i in 1:Hsize\n        Hmat[i, i] = -2*cos(k2-2pi*i/Hsize)\n    end\n\n    for i in 1:Hsize-1\n        Hmat[i, i+1] = -t\n        Hmat[i+1, i] = -t\n    end\n\n    Hmat[1, Hsize] = -t*exp(-im*k1)\n    Hmat[Hsize, 1] = -t*exp(im*k1)\n    \n    Hmat\nend","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"To calculate the dispersion, run:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> showBand(H; value=false, disp=true)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(Image: Dispersion of 2D square lattice with flux model)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"Then we can compute the Chern numbers using calcChern:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> calcChern(H)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"The output is:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(TopologicalNumber = [1, 1, -2, -2, 1, 1], Total = 0)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the first Chern number for each band.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the first Chern numbers for each band. Total is a quantity that should always return zero.","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> function H(k, p)\n    k1, k2 = k\n    t = p\n\n    Hsize = 6\n    Hmat = zeros(ComplexF64, Hsize, Hsize)\n\n    for i in 1:Hsize\n        Hmat[i, i] = -2 * cos(k2 - 2pi * i / Hsize)\n    end\n\n    for i in 1:Hsize-1\n        Hmat[i, i+1] = -t\n        Hmat[i+1, i] = -t\n    end\n\n    Hmat[1, Hsize] = -t * exp(-im * k1)\n    Hmat[Hsize, 1] = -t * exp(im * k1)\n\n    Hmat\nend\n\njulia> param = range(-2.0, 2.0, length=500)\njulia> calcPhaseDiagram(H, param, \"Chern\"; plot=true)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(Image: One-dimensional phase diagram)","category":"page"},{"location":"examples_old/#\\mathbb{Z}_2-numbers","page":"Examples","title":"mathbbZ_2 numbers","text":"","category":"section"},{"location":"examples_old/#The-Bernevig-Hughes-Zhang-(BHZ)-model","page":"Examples","title":"The Bernevig-Hughes-Zhang (BHZ) model","text":"","category":"section"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"As an example of a two-dimensional topological insulator, the BHZ model is presented here:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> function H(k) # BHZ\n    k1, k2 = k\n    t = 1\n\n    R0 = -2(cos(k1) + cos(k2)) + 1\n    R3 = 2sin(k2)\n    R4 = 2sin(k1)\n    R5 = -2t*(cos(k1) + cos(k2)) + 1\n\n    s0 = [1 0; 0 1]\n    sx = [0 1; 1 0]\n    sy = [0 -im; im 0]\n    sz = [1 0; 0 -1]\n\n    a0 = kron(s0, s0)\n    a1 = kron(sx, sx)\n    a2 = kron(sx, sy)\n    a3 = kron(sx, sz)\n    a4 = kron(sy, s0)\n    a5 = kron(sz, s0)\n\n    R0*a0+R3*a3+R4*a4+R5*a5\nend","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"To calculate the dispersion, execute:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> showBand(H; value=false, disp=true)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(Image: Dispersion of BHZ model)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"Next, we can compute the mathbbZ_2 numbers using calcZ2:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"julia> calcZ2(H)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"The output is:","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"(TopologicalNumber = [1, 1], Total = 0)","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the mathbbZ_2 number for each each pair of two energy bands.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the mathbbZ_2 numbers for each pair of two energy bands. Total is a quantity that should always return zero.","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"Total is a value that should consistently return zero.","category":"page"},{"location":"2D/Haldane/#Haldane-model","page":"Haldane model","title":"Haldane model","text":"","category":"section"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"Hamiltonian of Haldane model is given by:","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"julia> function H₀(k, p) # Haldane\n            k1, k2 = k\n            t₁ = 1\n            t₂, ϕ, m = p\n\n            h0 = 2t₂ * cos(ϕ) * (cos(k1) + cos(k2) + cos(k1 + k2))\n            hx = t₁ * (1 + cos(k1) + cos(k2))\n            hy = t₁ * (-sin(k1) + sin(k2))\n            hz = m - 2t₂ * sin(ϕ) * (sin(k1) + sin(k2) - sin(k1 + k2))\n\n            s0 = [1 0; 0 1]\n            sx = [0 1; 1 0]\n            sy = [0 -im; im 0]\n            sz = [1 0; 0 -1]\n\n            h0 .* s0 .+ hx .* sx .+ hy .* sy .+ hz .* sz\n       end","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"The band structure is computed as follows:","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"julia> H(k) = H₀(k, (1, π/3, 0.5))\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"(Image: Band structure of Haldane model)","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"Then we can compute the Chern numbers using FCProblem:","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"julia> prob = FCProblem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"The output is:","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"FCSolution{Vector{Int64}, Int64}([1, -1], 0)","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the first Chern number for each band.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the first Chern numbers for each band. Total is a quantity that should always return zero.","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"You can access these values as follows:","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"julia> sol.TopologicalNumber\n2-element Vector{Int64}:\n  1\n -1\n\njulia> sol.Total\n0","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"A one-dimensional phase diagram is given by:","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"julia> H(k, p) = H₀(k, (1, p, 2.5));\njulia> param = range(-π, π, length=1000);\n\njulia> prob = FCProblem(H);\njulia> sol = calcPhaseDiagram(prob, param; plot=true)\n(param = -3.141592653589793:0.006289474781961547:3.141592653589793, nums = [0 0; 0 0; … ; 0 0; 0 0])","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"(Image: One-dimensional phase diagram of Haldane model)","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"Also, two-dimensional phase diagram is given by:","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"julia> H(k, p) = H₀(k, (1, p[1], p[2]));\njulia> param1 = range(-π, π, length=100);\njulia> param2 = range(-6.0, 6.0, length=100);\n\njulia> prob = FCProblem(H);\njulia> sol = calcPhaseDiagram(prob, param1, param2; plot=true)\n(param1 = -3.141592653589793:0.06346651825433926:3.141592653589793, param2 = -6.0:0.12121212121212122:6.0, nums = [0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0;;; … ;;; 0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0])","category":"page"},{"location":"2D/Haldane/","page":"Haldane model","title":"Haldane model","text":"(Image: Two-dimensional phase diagram of Haldane model)","category":"page"},{"location":"lib/internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Modules = [TopologicalNumbers]\nPublic = false","category":"page"},{"location":"lib/internal/#TopologicalNumbers.BerryFluxAlgorithms","page":"Internal","title":"TopologicalNumbers.BerryFluxAlgorithms","text":"\n\n\n\n","category":"type"},{"location":"lib/internal/#TopologicalNumbers.BerryPhaseAlgorithms","page":"Internal","title":"TopologicalNumbers.BerryPhaseAlgorithms","text":"\n\n\n\n","category":"type"},{"location":"lib/internal/#TopologicalNumbers.FirstChernAlgorithms","page":"Internal","title":"TopologicalNumbers.FirstChernAlgorithms","text":"\n\n\n\n","category":"type"},{"location":"lib/internal/#TopologicalNumbers.SecondChernAlgorithms","page":"Internal","title":"TopologicalNumbers.SecondChernAlgorithms","text":"\n\n\n\n","category":"type"},{"location":"lib/internal/#TopologicalNumbers.TopologicalNumbersAlgorithms","page":"Internal","title":"TopologicalNumbers.TopologicalNumbersAlgorithms","text":"\n\n\n\n","category":"type"},{"location":"lib/internal/#TopologicalNumbers.WeylPointsAlgorithms","page":"Internal","title":"TopologicalNumbers.WeylPointsAlgorithms","text":"\n\n\n\n","category":"type"},{"location":"lib/internal/#TopologicalNumbers.Z2Algorithms","page":"Internal","title":"TopologicalNumbers.Z2Algorithms","text":"\n\n\n\n","category":"type"},{"location":"lib/internal/#TopologicalNumbers.BerryPhase!-Tuple{Any, TopologicalNumbers.Params}","page":"Internal","title":"TopologicalNumbers.BerryPhase!","text":"\n\n\n\n","category":"method"},{"location":"lib/internal/#TopologicalNumbers.ChernPhase!-Tuple{Any, TopologicalNumbers.Params}","page":"Internal","title":"TopologicalNumbers.ChernPhase!","text":"\n\n\n\n","category":"method"},{"location":"lib/internal/#TopologicalNumbers.SecondChernPhase!-Union{Tuple{Any}, Tuple{T}} where T<:TopologicalNumbers.TopologicalNumbersParallel","page":"Internal","title":"TopologicalNumbers.SecondChernPhase!","text":"SecondChernPhase!(v; parallel::T=UseSingleThread()) where {T<:TopologicalNumbersParallel}\n\nThis function updates the second Chern number for the given system v. The parallel argument specifies whether to use parallel computation or not.\n\nArguments\n\nv: The system to compute the second Chern number for.\nparallel: (optional) The parallel computation mode. Default is UseSingleThread().\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#TopologicalNumbers.SecondChernPhase-Union{Tuple{Any}, Tuple{T}} where T<:TopologicalNumbers.TopologicalNumbersParallel","page":"Internal","title":"TopologicalNumbers.SecondChernPhase","text":"SecondChernPhase(p; parallel::T=UseSingleThread()) where {T<:TopologicalNumbersParallel}\n\nMain function to execute the simulation and calculate the second Chern number.\n\nArguments\n\np: Parameters for the simulation.\nparallel: Parallelization strategy. Default is UseSingleThread().\n\nReturns\n\nchern: The second Chern number.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#TopologicalNumbers.Z2Phase!-Tuple{Any, Any, TopologicalNumbers.Params}","page":"Internal","title":"TopologicalNumbers.Z2Phase!","text":"\n\n\n\n","category":"method"},{"location":"lib/internal/#TopologicalNumbers.Z2Phase!-Tuple{Any, TopologicalNumbers.Params}","page":"Internal","title":"TopologicalNumbers.Z2Phase!","text":"\n\n\n\n","category":"method"},{"location":"lib/internal/#TopologicalNumbers.weylpoint!-NTuple{6, Any}","page":"Internal","title":"TopologicalNumbers.weylpoint!","text":"\n\n\n\n","category":"method"},{"location":"2D/Kitaev-Honeycomb/#Kitaev-honeycomb-model","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"","category":"section"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"Hamiltonian of Kitaev honeycomb model is given by:","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"julia> function H₀(k, p) # Kitaev\n            k1, k2 = k\n            K₁ = 1\n            K₂ = p\n\n            hx = -K₂ * (sin(k2) - sin(k1) + sin(k1 - k2))\n            hy = -K₁ * (sin(k1) + sin(k2))\n            hz = K₁ * (cos(k1) + cos(k2) + 1)\n\n            sx = [0 1; 1 0]\n            sy = [0 -im; im 0]\n            sz = [1 0; 0 -1]\n\n            hx .* sx .+ hy .* sy .+ hz .* sz\n       end","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"The band structure is computed as follows:","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"julia> H(k) = H₀(k, 0.5)\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"(Image: Band structure of Kitaev honeycomb model)","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"Then we can compute the Chern numbers using FCProblem:","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"julia> prob = FCProblem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"The output is:","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"FCSolution{Vector{Int64}, Int64}([-1, 1], 0)","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the first Chern number for each band.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the first Chern numbers for each band. Total is a quantity that should always return zero.","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"You can access these values as follows:","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"julia> sol.TopologicalNumber\n2-element Vector{Int64}:\n -1\n  1\n\njulia> sol.Total\n0","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"julia> param = range(-1, 1, length=1000);\njulia> calcPhaseDiagram(H₀, param, \"Chern\"; plot=true)\n(param = -1.0:0.002002002002002002:1.0, nums = [1 -1; 1 -1; … ; -1 1; -1 1])","category":"page"},{"location":"2D/Kitaev-Honeycomb/","page":"Kitaev honeycomb model","title":"Kitaev honeycomb model","text":"(Image: One-dimensional phase diagram of Kitaev honeycomb model)","category":"page"},{"location":"2D/BHZ/#The-Bernevig-Hughes-Zhang-(BHZ)-model","page":"BHZ model","title":"The Bernevig-Hughes-Zhang (BHZ) model","text":"","category":"section"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"As an example of a two-dimensional topological insulator, the BHZ model is presented here:","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"julia> using LinearAlgebra\njulia> function H₀(k, p) # BHZ\n    k1, k2 = k\n    tₛₚ = 1\n    t₁ = ϵ₁ = 2\n    ϵ₂, t₂ = p\n\n    ϵ = -t₁*(cos(k1) + cos(k2)) + ϵ₁/2\n    R1 = 0\n    R2 = 0\n    R3 = 2tₛₚ*sin(k2)\n    R4 = 2tₛₚ*sin(k1)\n    R0 = -t₂*(cos(k1) + cos(k2)) + ϵ₂/2\n\n    s0 = [1 0; 0 1]\n    sx = [0 1; 1 0]\n    sy = [0 -im; im 0]\n    sz = [1 0; 0 -1]\n\n    I0 = Matrix{Int64}(I, 4, 4)\n    a1 = kron(sz, sx)\n    a2 = kron(sz, sy)\n    a3 = kron(sz, sz)\n    a4 = kron(sy, s0)\n    a0 = kron(sx, s0)\n\n    ϵ .* I0 .+ R1 .* a1 .+ R2 .* a2 .+ R3 .* a3 .+ R4 .* a4 .+ R0 .* a0\nend","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"To calculate the dispersion, execute:","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"julia> H(k) = H₀(k, (2, 2))\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"(Image: Dispersion of BHZ model)","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"Next, we can compute the mathbbZ_2 numbers using Z2Problem:","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"julia> prob = Z2Problem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"The output is:","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"Z2Solution{Vector{Int64}, Nothing, Int64}([1, 1], nothing, 0)","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the mathbbZ_2 number for each pair of two energy bands.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the mathbbZ_2 numbers for each pair of two energy bands. Total is a quantity that should always return zero.","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"You can access these values as follows:","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"julia> sol.TopologicalNumber\n2-element Vector{Int64}:\n 1\n 1\n\njulia> sol.Total\n0","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"julia> H(k, p) = H₀(k, (p, 0.25));\njulia> param = range(-2, 2, length=1000);\n\njulia> prob = Z2Problem(H);\njulia> sol = calcPhaseDiagram(prob, param; plot=true)\n(param = -2.0:0.004004004004004004:2.0, nums = [0 0; 0 0; … ; 0 0; 0 0])","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"(Image: One-dimensional phase diagram of BHZ model)","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"Also, two-dimensional phase diagram is given by:","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"julia> param1 = range(-2, 2, length=100);\njulia> param2 = range(-0.5, 0.5, length=100);\n\njulia> prob = Z2Problem(H₀);\njulia> calcPhaseDiagram(prob, param1, param2; plot=true)","category":"page"},{"location":"2D/BHZ/","page":"BHZ model","title":"BHZ model","text":"(Image: Two-dimensional phase diagram of BHZ model)","category":"page"},{"location":"2D/Kane-Mele/#The-Kane-Mele-model","page":"Kane-Mele model","title":"The Kane-Mele model","text":"","category":"section"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"As an example of a two-dimensional topological insulator, the Kane-Mele model is presented here:","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"julia> function H₀(k, p) # Kane-Mele\n           k1, k2 = k\n           t = 1\n           λₛₒ = p\n\n           R1 = 0\n           R2 = 0\n           R3 = 2λₛₒ*(sin(k1) - sin(k2) - sin(k1-k2))\n           R4 = -t*(sin(k1) + sin(k2))\n           R0 = -t*(cos(k1) + cos(k2) + 1)\n\n           s0 = [1 0; 0 1]\n           sx = [0 1; 1 0]\n           sy = [0 -im; im 0]\n           sz = [1 0; 0 -1]\n\n           a1 = kron(sz, sx)\n           a2 = kron(sz, sy)\n           a3 = kron(sz, sz)\n           a4 = kron(sy, s0)\n           a0 = kron(sx, s0)\n\n           R1 .* a1 .+ R2 .* a2 .+ R3 .* a3 .+ R4 .* a4 .+ R0 .* a0\n       end","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"To calculate the dispersion, execute:","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"julia> H(k) = H₀(k, 0.5)\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"(Image: Dispersion of Kane-Mele model)","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"Next, we can compute the mathbbZ_2 numbers using Z2Problem:","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"julia> prob = Z2Problem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"The output is:","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"Z2Solution{Vector{Int64}, Nothing, Int64}([1, 1], nothing, 0)","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the mathbbZ_2 number for each pair of two energy bands.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the mathbbZ_2 numbers for each pair of two energy bands. Total is a quantity that should always return zero.","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"You can access these values as follows:","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"julia> sol.TopologicalNumber\n2-element Vector{Int64}:\n 1\n 1\n\njulia> sol.Total\n0","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"julia> param = range(-1.0, 1.0, length=1001)\n\njulia> prob = Z2Problem(H₀);\njulia> sol = calcPhaseDiagram(prob, param; plot=true)\n(param = -1.0:0.002:1.0, nums = [1 1; 1 1; … ; 1 1; 1 1])","category":"page"},{"location":"2D/Kane-Mele/","page":"Kane-Mele model","title":"Kane-Mele model","text":"(Image: One-dimensional phase diagram of Kane-Mele model)","category":"page"},{"location":"2D/Thouless/#The-Thouless-pump-model","page":"Thouless pumping","title":"The Thouless pump model","text":"","category":"section"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"<!– As an example of a two-dimensional topological insulator, the Kane-Mele model is presented here: –>","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"julia> function H₀(k, p) # Thouless pump\n           k1, t = k\n           Δ, m₀ = p\n\n           R1 = -Δ*sin(k1)\n           R2 = -Δ*(1-cos(k1))\n           R3 = m₀*sin(t)\n           R4 = -(1+cos(t))*sin(k1)\n           R0 = -(1-cos(t))-(1+cos(t))*cos(k1)\n\n           s0 = [1 0; 0 1]\n           sx = [0 1; 1 0]\n           sy = [0 -im; im 0]\n           sz = [1 0; 0 -1]\n\n           a1 = kron(sy, sx)\n           a2 = kron(sy, sy)\n           a3 = kron(sz, sz)\n           a4 = kron(s0, sy)\n           a0 = kron(s0, sx)\n\n           R1 .* a1 .+ R2 .* a2 .+ R3 .* a3 .+ R4 .* a4 .+ R0 .* a0\n       end","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"<!– To calculate the dispersion, execute:","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"julia> H(k) = H₀(k, 0.5)\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"(Image: Dispersion of Kane-Mele model)","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"Next, we can compute the mathbbZ_2 numbers using calcZ2:","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"julia> calcZ2(H)","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"The output is:","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"(TopologicalNumber = [1, 1], Total = 0)","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the mathbbZ_2 number for each pair of two energy bands.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the mathbbZ_2 numbers for each pair of two energy bands. Total is a quantity that should always return zero.","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"julia> param = range(-1.0, 1.0, length=1001)\njulia> calcPhaseDiagram(H₀, param, \"Z2\"; plot=true)","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"(Image: One-dimensional phase diagram of Kane-Mele model) –>","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"<!– Also, two-dimensional phase diagram is given by:","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"julia> param = range(-1.0, 1.0, length=101)\njulia> calcPhaseDiagram(H₀, param, param, \"Z2\"; plot=true)","category":"page"},{"location":"2D/Thouless/","page":"Thouless pumping","title":"Thouless pumping","text":"(Image: Two-dimensional phase diagram of Kane-Mele model) –>","category":"page"},{"location":"3D/Weyl/#Weyl-semimetal","page":"Weyl semimetal","title":"Weyl semimetal","text":"","category":"section"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"A three-dimensional example is presented here:","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> function H₀(k, p) # Weyl\n    k1, k2, k3 = k\n    t1, t2, t3, m, k0 = p\n\n    h0 = 0\n    hx = 2t1*(cos(k1) - cos(k0)) + m*(2 - cos(k2) - cos(k3))\n    hy = 2t2*sin(k2)\n    hz = 2t3*sin(k3)\n\n    s0 = [1 0; 0 1]\n    sx = [0 1; 1 0]\n    sy = [0 -im; im 0]\n    sz = [1 0; 0 -1]\n\n    h0 .* s0 .+ hx .* sx .+ hy .* sy .+ hz .* sz\nend","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"The location of the Weyl point can be determined by fixing one component of the wavenumber vector and calculating the Chern number as follows:","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> p0 = (1, 1, 1, 2, 2pi*2/5);\njulia> H(k) = H₀(k, p0);\njulia> prob = WCSProblem(H, \"k1\");\njulia> sol = solve(prob; plot = true)\nWCSSolution{String, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Matrix{Int64}}(\"k1\", 6.283185307179587e-5:0.12319971190548208:6.160048427127176, [0 0; 0 0; … ; 0 0; 0 0])","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"The first argument kn in the named tuple is a fixed component of the wavenumber vector.  The second argument param stores a range of fixed wavenumber vectors. Take 2pi from 0 by default. The third argument nums is a matrix that stores the Chern number of each band in each kn.","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"You can access these values as follows:","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> sol.kn\n\"k1\"\n\njulia> sol.nums\n51×2 Matrix{Int64}:\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 1  -1\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n 0   0\n\njulia> sol.param\n6.283185307179587e-5:0.12319971190548208:6.160048427127176","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"(Image: Chern surface of k1)","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> prob = WCSProblem(H, \"k2\");\njulia> sol = solve(prob; plot = true)","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"(Image: Chern surface of k2)","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> prob = WCSProblem(H, \"k3\");\njulia> sol = solve(prob; plot = true)","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"(Image: Chern surface of k3)","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"Or, Weyl points can be found as follows:","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> prob = WPProblem(H);\njulia> result = solve(prob)\nWPSolution{Vector{Vector{Vector{Int64}}}, Int64, Vector{Vector{Int64}}}([[[4000, 0, 0], [6000, 0, 0]], [[4000, 0, 0], [6000, 0, 0]]], 10000, [[1, -1], [-1, 1]])","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"The second argument N in the named tuple is the number of Brillouin zone divisions. The first argument WeylPoint represents the the wavenumber vector of position with the Weyl points. The third argument Nodes stores the node at the Weyl points.","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"WeylPoint can be converted to a wavenumber vector as follows:","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> 2pi*result.WeylPoint[1] / result.N .- pi*[ones(3), ones(3)]\n2-element Vector{Vector{Float64}}:\n [-0.6283185307179586, -3.141592653589793, -3.141592653589793]\n [0.6283185307179586, -3.141592653589793, -3.141592653589793]","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"If you already know the wavenumber vector of the Weyl point, you can calculate the node as follows:","category":"page"},{"location":"3D/Weyl/","page":"Weyl semimetal","title":"Weyl semimetal","text":"julia> H(k) = H₀(k .- 2pi*1e-5, p0)\njulia> prob = WNProblem(H, result.WeylPoint[1][1], result.N);\njulia> sol = solve(prob)\nWNSolution{Vector{Int64}, Vector{Int64}, Int64}([1, -1], [4000, 0, 0], 10000)","category":"page"},{"location":"1D/Kitaev-Chain/#The-Kitaev-chain-model","page":"Kitaev Chain","title":"The Kitaev chain model","text":"","category":"section"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"Here's a simple example of the Kitaev chain Hamiltonian:","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"julia> using TopologicalNumbers\njulia> function H₀(k, p)\n            μ, Δ = p\n            t = 1\n\n            [\n                -μ-2t*cos(k) 2im*Δ*sin(k)\n                -2im*Δ*sin(k) μ+2t*cos(k)\n            ]\n        end","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"The band structure is computed as follows:","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"julia> H(k) = H₀(k, (-1.0, 0.5))\njulia> showBand(H; value=false, disp=true)","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"(Image: Band structure of Kitaev chain model)","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"Next, we can calculate the winding numbers using BPProblem:","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"julia> prob = BPProblem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"The output is:","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"BPSolution{Vector{Int64}, Int64}([1, 1], 0)","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"The first argument TopologicalNumber in the named tuple is an vector that stores the winding number for each band.  The vector is arranged in order of bands, starting from the one with the lowest energy. The second argument Total stores the total of the winding numbers for each band (mod 2). Total is a quantity that should always return zero.","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"You can access these values as follows:","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"julia> sol.TopologicalNumber\n2-element Vector{Int64}:\n 1\n 1\n\njulia> sol.Total\n0","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"One-dimensional phase diagram is given by:","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"julia> H(k, p) = H₀(k, (p, 1.0));\njulia> param = range(-3.0, 0, length=601);\n\njulia> prob = BPProblem(H);\njulia> sol = calcPhaseDiagram(prob, param; plot=true)\n(param = -3.0:0.005:0.0, nums = [0 0; 0 0; … ; 1 1; 1 1])","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"(Image: One-dimensional phase diagram of Kitaev chain model)","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"Also, two-dimensional phase diagram is given by:","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"julia> param1 = range(-3.0, 3.0, length=101);\njulia> param2 = range(-1.0, 1.0, length=101);\n\njulia> prob = BPProblem(H₀);\njulia> calcPhaseDiagram(prob, param1, param2; plot=true)\n(param1 = -3.0:0.06:3.0, param2 = -1.0:0.02:1.0, nums = [0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0;;; … ;;; 0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0;;; 0 0 … 0 0; 0 0 … 0 0])","category":"page"},{"location":"1D/Kitaev-Chain/","page":"Kitaev Chain","title":"Kitaev Chain","text":"(Image: Two-dimensional phase diagram of Kitaev chain model)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TopologicalNumbers","category":"page"},{"location":"#TopologicalNumbers.jl","page":"Home","title":"TopologicalNumbers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TopologicalNumbers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TopologicalNumbers.jl is a Julia package designed to calculate topological numbers, such as the Chern numbers and mathbbZ_2 numbers,  using a numerical approach based on the Fukui-Hatsugai-Suzuki method [1, 2],  the Shiozaki method [3, 4],  or method of calculating the Weyl nodes [5–8].","category":"page"},{"location":"","page":"Home","title":"Home","text":"This software is released under the MIT License, please see the LICENSE file for more details.   It is confirmed to work on Julia 1.6 (LTS) and 1.10.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install TopologicalNumbers.jl, run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add TopologicalNumbers","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, you can use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"TopologicalNumbers\")","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package includes the following functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Calculation of the dispersion relation.\nProvides numerical calculation methods for various types of topological numbers.\nCalculation of the phase diagram.\nUtility functions for plotting.\nSupport parallel computing using MPI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The correspondence between the spatial dimension of the system and the supported topological numbers is as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<table>\n    <tr>\n        <th>Dimension</th>\n        <th>Function</th>\n    </tr>\n    <tr>\n        <td>0D</td>\n        <td>Calculation of Weyl nodes ($\\mathbb{Z}$)<br></td>\n    </tr>\n    <tr>\n        <td>1D</td>\n        <td>Calculation of Berry Phases ($\\mathbb{Z}$)<br></td>\n    </tr>\n    <tr>\n        <td>2D</td>\n        <td>Calculation of local Berry Fluxes ($\\mathbb{Z}$)<br>Calculation of first Chern numbers ($\\mathbb{Z}$)<br>Calculation of $\\mathbb{Z}_{2}$ numbers ($\\mathbb{Z}_{2}$)<br></td>\n    </tr>\n    <tr>\n        <td>3D</td>\n        <td>Calculation of Weyl nodes ($\\mathbb{Z}$)<br> Calculation of first Chern numbers in sliced Surface ($\\mathbb{Z}$)<br>Finding Weyl points ($\\mathbb{Z}$)<br></td>\n    </tr>\n    <tr>\n        <td>4D</td>\n        <td>Calculation of second Chern numbers ($\\mathbb{Z}$)<br></td>\n    </tr>\n</table>","category":"page"},{"location":"4D/LatticeDirac/#Lattice-Dirac-model","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"","category":"section"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"Hamiltonian of lattice Dirac model is given by:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"julia> function H₀(k, p) # lattice Dirac\n            k1, k2, k3, k4 = k\n            m = p\n\n            # Define Pauli matrices and Gamma matrices\n            σ₀ = [1 0; 0 1]\n            σ₁ = [0 1; 1 0]\n            σ₂ = [0 -im; im 0]\n            σ₃ = [1 0; 0 -1]\n            g1 = kron(σ₁, σ₀)\n            g2 = kron(σ₂, σ₀)\n            g3 = kron(σ₃, σ₁)\n            g4 = kron(σ₃, σ₂)\n            g5 = kron(σ₃, σ₃)\n\n            h1 = m + cos(k1) + cos(k2) + cos(k3) + cos(k4)\n            h2 = sin(k1)\n            h3 = sin(k2)\n            h4 = sin(k3)\n            h5 = sin(k4)\n\n            # Return the Hamiltonian matrix\n            h1 .* g1 .+ h2 .* g2 .+ h3 .* g3 .+ h4 .* g4 .+ h5 .* g5\n        end","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"You can also use our preset Hamiltonian function LatticeDirac to define the same Hamiltonian matrix as follows:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"julia> H₀(k, p) = LatticeDirac(k, p)","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"Then we can compute the second Chern numbers using SCProblem:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"julia> H(k) = H₀(k, -3.0)\n\njulia> prob = SCProblem(H);\njulia> sol = solve(prob)","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"The output is:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"SCSolution{Float64}(0.9793607631927376)","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"The argument TopologicalNumber in the named tuple stores the second Chern number with some filling condition that you selected in the options (the default is the half-filling). ","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"You can access this value as follows:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"julia> sol.TopologicalNumber\n0.9793607631927376","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"A phase diagram is given by:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"julia> param = range(-4.9, 4.9, length=10);\n\njulia> N = 30; # number of k-points in each direction\njulia> prob = SCProblem(H₀, N); # N is optional argument\njulia> sol = calcPhaseDiagram(prob, param; plot=true)\n(param = -4.9:1.0888888888888888:4.9, nums = [0.00024580085568788514, 0.8920579621583358, 0.9779212824560908, -2.8575405041314244, -2.915655604396968, 2.9165403378212695, 2.8604644187734776, -0.9777674289766198, -0.886041497183358, -0.0002442110189681556])","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"(Image: Phase diagram of lattice Dirac model)","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"A more dense diagram can also be obtained:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"julia> param = range(-4.9, 4.9, length=50)\njulia> sol = calcPhaseDiagram(prob, param; plot=true)","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"(Image: Dense phase diagram of lattice Dirac model)","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"Since the system dimension is high, a computational cost is high comparing with other low dimensional cases.","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"If you want to use a parallel environment, you can utilize MPI.jl. Let's create a file named test.jl with the following content:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"using TopologicalNumbers\nusing MPI\n\nH₀(k, p) = LatticeDirac(k, p)\nH(k) = H₀(k, -3.0)\n\nparam = range(-4.9, 4.9, length=10)\n\nprob = SCProblem(H₀)\nresult = calcPhaseDiagram(prob, param; parallel=UseMPI(MPI), progress=true)\n\nplot1D(result; labels=true, disp=false, pdf=true)","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"You can perform calculations using mpirun (for example, with 4 cores) as follows:","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"mpirun -np 4 julia --project test.jl","category":"page"},{"location":"4D/LatticeDirac/","page":"Lattice Dirac model","title":"Lattice Dirac model","text":"For more details, refer to the MPI.jl document at https://juliaparallel.org/MPI.jl/stable/.","category":"page"}]
}
